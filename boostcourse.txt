<CS50> 데이비드 j.말란

  1강 컴퓨팅 사고 
컴퓨터사이언스의 개론?에 대한 강의인 cs50에서 첫 강의로 컴퓨팅적인 사고를 주제로 삼았습니다. 강의 순서는
1) 2진법
2) 정보의 표현
3) 알고리즘 
4) 스크래치(비주얼적으로 표현된 코딩 학습도구)
이렇게 4파트로 이루어져 있었습니다. 

1-1 2진법 - 우선 2진법에 대한 이야기는 컴퓨터의 기본 요소이기 때문에 첫 주제로 삼으신거 같습니다.
제가 살아가면서 정확한 이유는 모르지만 얼핏 듣기로는 컴퓨터는 0과 1로 이루어져있다고 듣고는 했습니다. 예전 crashcourse 라는 
유튜브 채널의 컴퓨터 사이언스 강의들을 들은적이 있습니다. 이 cs50강의에서도 언급하였던 것이 컴퓨터의 기본 단위가 트랜지스터 라는 
것이었습니다. 트랜지스터라는 온 오프 상태를 나타낼수 있는 것으로 트랜지스터를 잘 이용하여 2진법으로 표현할 수 있고 또 불리언 값
true는 1, false는 0 라고 간주하여 표현하기도 합니다. 그리고 몇개의 트랜지스터를 알맞게 연결하여 논리회로를 표현하고 , 
더욱 많은 0과 1로 일종의 주소를 만들어 RAM이나 ROM 같은 저장공간, 또 CPU자체가 이런것들을 모아놓은 두뇌라고 들었습니다.
이런 것들을 대략적으로 말하여 컴퓨터가 0과 1로 이루어져 있다 라는 이야기인것 같습니다.

1-2 정보의 표현 - 0과 1로 이루어진 컴퓨터에서 숫자는 2진법을 10진법으로 해석 가능할 것입니다. 하지만 2진법인 숫자를 어떻게 
문자, 이미지, 소리 등을 표현할 수 있을까요? 수십년전 0과 1로 알파벳같은 문자를 표현하기위해 일종의 약속을 하였습니다. "2진법으로 
몇번이라고 하면 이것은 이 알파벳 이야!" 라는 식으로 말입니다. 이것을 ASCII 아스키코드라고 합니다.
American Standard Code for Information Interchange 의 약자인데요 이름에서도 보이듯이 미국에서 정한 기준입니다. 하지만 요즘은 
단순히 알파벳정도만 쓰는정도가 아니죠 여러 나라의 문자도 있고 기본적으로 🤣이런 이모지 도 내장되어있는 새로운 기준을 씁니다.
이 기준의 이름은 Unicode라는 이름입니다. 문자는 이렇게 하나씩 코드를 나열하여 표현한다고 하고 이미지 같은 경우는 어떨까요
다들 픽셀이라는 말을 들어봤을 것입니다. 컴퓨터나 스마트폰 태블릿PC등 디지털 디바이스에서 이미지나 화면의 해상도를 말할때 
픽셀이 얼마나 많느냐 라고 합니다. 이미지를 이루는 픽셀들에 컴퓨터는 2진법으로도 좌표를 지정 할수 있을 것입니다. 또 RGB이라는 
빨강,초록,파랑 이라는 빛의 3원색을 어떻게 조합하느냐로 색을 지정할 수도 있을것입니다. 그러면 하나하나 지정된 좌표의 픽셀이 
어떠한 색이라고 지정한다면 이 픽셀들을 쌓아 하나의 이미지로 보이게 할 수도 있을 것입니다. 이것은 사실 지금 쓰고 있는 텍스트에도 
적용되는 사항입니다 . 이 텍스트도 단색으로 표현된 이미지라고 할 수도 있기때문입니다.😁 소리, 음악, 영상은 어떻게 표현할까요? 
일단 영상의 경우 이미지의 연장선상에 있습니다. 여러 연결된 이미지를 빠르게 보여주는것이 영상입니다. 뇌가 충분히 정지된 이미지를 
움직이고 있다고 착각할 만큼 빠르게 보여주면 되는것이었습니다. 음악, 소리는 같은 원리인데요 소리는 시간에따라 크기, 음계를 진동수
에 하나 하나 숫자를 대입하여 저장 할 수있습니다.

1-3 알고리즘 - 위에서 정보를 입력하는 방식을 배웠습니다. 하지만 컴퓨터는 단순히 정보를 입력하는 것만 할수 있는게 아니죠 
입력한 정보를 어떠한 과정을 거쳐 원하는 출력값으로 받을 수 있습니다. 지금 말한 어떠한 과정이 알고리즘이라고 할 수 있을것 입니다.
알고리즘은 입력값을 출력값의 형태로 바꾸기 위해 어떤 명령들이 수행 되어야 하는지에 대한 규칙들의 순서적 나열입니다.
좋은 알고리즘의 요건에는 정확함과 효율적임이 있어야 할 것입니다. 정보를 가공하는데에 있어 정확한 값이 나오도록 명령들을 나열해야 
할 것이고, 효율적인 명령들로 정보를 가공해야 컴퓨터의 리소스를 절약하여 성능적으로 많은 이득을 봐야 할 것입니다.
예를 들면 탐색하는 알고리즘으로 100페이지의 전화번호부에 천성욱 이라는 이름을 찾는다고 하면 일단 맨 첫페이지 부터 한장씩 찾아보는 방법
이 하나 있을것이고 혹은 전화번호부의 중간을 펼쳐서 이름이 있는지 확인하고 절반의 앞이나 뒤쪽중 해당하는 곳에 절반을 다시 열어보고를 
반복하여 찾는 방법도 있을 것입니다. 둘다 시간을 들이면 확실히 이름이 어디있는지 찾을 수 있을것입니다 이름이 처음부터 전화번호부에 없지만
않다면요. 두 방법다 알고리즘으로써 정확성은 갖추고 있다고 할 수 있겠습니다. 그렇다면 어느 쪽이 효율적인가 살펴보면 첫번째 방법은 
가장 오래걸리는 경우 100페이지를 전부 봐야합니다. 반면 두번째 절반 씩 찾아보는 경우 첫시도에 50페이지, 두번째에 25페이지, 세번째에 12나 
13페이지, 네번째에 6페이지 정도, 다섯번째에 3페이지, 여섯번째에 2페이지 , 일곱번째에 1페이지 가 남는 가장 오래걸리는 경우에 일곱정도에 
찾을수 있을 것입니다.최대 100번의 시도와 7번의 시도 어느 쪽이 효율적인가요 이런식으로 같은 결과를 내고 같은 정확성을 가진 알고리즘이지만 
효율성에는 차이가 있을수 있습니다. 또 이런 알고리즘을 프로그래밍적이면서 사람의 언어로 적어보는 것을 의사코드라고 합니다.예를 들면
1.전화번호부를 집는다.
2.전화번호부의 중간을 펼친다.
3.페이지를 확인한다
4.만약 찾는 이름이 있다면
5.  그 번호로 전화한다.
6.만약 찾는 이름이 절반의 페이지중 앞쪽에 있다면
7.  전화번호부의 앞쪽 절반을 펼친다.
8.  3번째 줄의 명령으로 간다.
9.만약 찾는 이름이 절반의 페이지중 뒷쪽에 있다면
10. 전화번호부의 뒷쪽 절반을 펼친다.
11. 3번째 줄의 명령으로 간다.
12.이도 저도 아니면
13.행위를 중지한다.
이렇게 적는 것이 의사코드입니다. 

  2강 C언어
C언어는 현재까지 사용되는 언어중 매우 오래된 언어에 속하고 또 로우레벨의 언어 컴퓨터 언어에 가까운 언어라고 합니다.
파이썬이나 자바스크립트 같은 언어는 보다 사람 친화적인 언어 하이레벨 언어라고도 불리는데 이때 로우레벨 하이레벨은 
뭐가 더 좋고 나쁜것이 아닙니다. 로우레벨은 기계친화적이고 사람이 배워 사용하기 어려운 언어이지만 속도나 성능은 하이레벨언어에
비해 좋습니다. 하이레벨의 언어는 반대로 배우기쉬운 언어지만 상대적으로 속도가 느립니다. 현대의 컴퓨터는 컴퓨터자체의 
연산속도가 매우 빠르다 보니 이 언어끼리의 속도차이는 생각보다 중요하지 않을 수 있지만 컴퓨터프로그램 중에서도 속도가 중요한 게임
같은데서는 C언어 계열을 사용하고 pc가 아닌 에어컨이나 공장용 혹은 농장에서 사용하는 기계에 들어가는 컴퓨터의 경우 pc만큼의
속도나 메모리가 없기때문에 C언어의 속도나 성능이 필요합니다. 이렇게 용도가 다를뿐 하이 로우 라고 급의 차이는 없습니다.
C언어나 프로그래밍 언어를 배우면서 가장 처음 해보는 것에 hello, world!를 출력해볼텐데요 
#include <stdio.h>

int main(void){
  printf("hello, world!");
}
이런 코드가 됩니다. 첫째 줄에 include한 stdio.h는 printf함수를 사용하기위한 라이브러리 라고 합니다. 파이썬의 경우 단순히
print("hello, world!")
이렇게 간결한 코드로 같은 명령을 내릴수 있습니다. 이런 차이가 로우레벨과 하이레벨언어의 차이점일 것입니다.

"hello, world!"같이 큰 따옴표 안에 하나 이상의 문자가 적혀있으면 이 데이터는 문자열이라는 자료형입니다. 자료형에는 문자열, 정수,
실수, 불리언등 여러 자료형이 있습니다.

사용자 정의 함수 - C언어에서 사용자 정의 함수를 만드는 방법을 학습해 보겠습니다. cough라는 텍스트를 콘솔에 출력하는 함수입니다. 

#include <stdio.h>

void cough(void)
{
  printf("cough\n");
}

int main(void)
{
  for (int i = 0; i < 3; i++){
    cough();
  }
}

이 코드는 cough를 3번 출력해주는 코드입니다. 실제 작동하는 main함수에서 사용자 정의 함수인 cough함수를 for 문으로 3번 반복 실행 했습니다.
작동을 하긴 하지만 메인함수가 밑에 있으면 나중에 사용자 정의 함수가 많아지면 가독성이 떨어질 수 있으니 한번 cough함수를 메인 함수 밑으로 옯겨 봤습니다.

#include <stdio.h>

int main(void)
{
  for (int i = 0; i < 3; i++){
    cough();
  }
}

void cough(void)
{
  printf("cough\n");
}

이렇게 코드를 컴파일 하면 오류가 발생합니다. 메인함수안에 cough()라는 함수를 찾을 수 없다는 말인데 이렇게 C언어에서는 코드가 위에서 아래로 왼쪽에서 오른쪽으로
순서대로만 실행되기떄문에 밑에 사용자 정의 함수를 정의 하기전에 먼저 사용하여 오류가 발생하였습니다. 이럴때 어떠한 테크닉을 쓰면 해결이 된다고 합니다.

#include <stdio.h>

void cough(void);

int main(void)
{
  for (int i = 0; i < 3; i++){
    cough();
  }
}

void cough(void)
{
  printf("cough\n");
} 

이렇게 일단 위에 이름만이라도 함수를 정의 해놓으면 메인 함수에서 실행할때 이런 이름의 함수가 있기는 하다는 듯이 코드 끝까지 읽고 실행이 됩니다.
맨위에 한줄로 적어놓은 간이 함수를 프로토 타입이라고 부릅니다. 이번엔 cough를 for루프로 감싸지 말고 함수 자체에 매개변수를 주어 반복 실행 하고 
싶습니다.

void cough(int n)
{
  for (int i; i < n; i++)
  {
    printf("cough\n");
  }
}

이런 함수를 만들면 함수의 괄호안에 반복하고 싶은 만큼의 정수를 적으면 숫자 만큼 기침을 반복하는 기능을 구현한 것입니다. 이런 기능을 구현하고 
다른 사용자는 이 함수를 사용하면 자세한 구현 방법은 몰라도 직관적으로 기침을 출력해주는 함수고 괄호에는 반복할 정수를 적으면 되겠구나 라고 
알 것입니다. 추상화의 영역입니다. 제가 프로그래밍으로 서비스를 만들며 기능을 구현 할 때 다른 프로그래머가 먼저 만들어놓은 코드들을 가져와서 
쓰는것은 아주 흔한일입니다. 하지만 그렇게 가져와서 쓸때 마다 어떻게 구현됐는지 원리를 하나하나 알아야한다면 작업속도가 매우 느려질 것입니다.
그렇다고 코드의 의미를 알려고 하는것 자체가 잘못된 행동은 아닐겁니다. 오히려 공부가 되면 됐지 다만 비지니스 적으로 효율성을 따지면 별로 좋은
태도가 아닐 것이라는 이야기입니다. 
다음은 조금 다른 사용자 정의 함수 입니다.
#include <cs50.h>
#include <stdio.h>

int get_positive_int(void);

int main(void)
{
    int i = get_positive_int();
    printf("%i\n", i);
}

int get_positive_int(void)
{
    int n;
    do
    {
        n = get_int("Positive Integer: ");
    }
    while (n < 1);
    return n;
}
이번에 CS50 라이브러리도 인클루드했고 프로토타입 함수와 밑에 사용자정의 함수 앞에 int라고 선언 되어있습니다. 이전 까지는 
void function(void) 이런 식이었는데요 이 의미는 앞이 void 이면 함수가 어떤 값을 받아 반환되는게 아닌 경우 입니다.
cough 함수도 printf를 실행했을 뿐 함수가 어떤 값을 반환한것은 아니었습니다. 그러면 이번 get_positive_int 함수는 어떤 기능을 구현 한것
이나면 우선 아무 값이 없는 정수를 받을 수있는 변수 n을 선언합니다. 그 후 do while 문은 우선 do{}에 있는 명령을 실행한 후 while의 
불리언 값에 의해 do{}의 명령이 다시 루프 할지 확인하는 문법입니다. 그러면 do에서 get_int로 어떤 정수값을 입력 받습니다. 질문은 
양의 정수를 달라고 하는군요 그 값을 변수 n에 담습니다. 이제 while로 반복할지 안할지 체크 합니다. n에 저장된 값이 정수 1보다 
작으면 반복합니다. 1이상인 숫자를 입력할때까지. 새로운 개념들이 몇개 있었습니다. int n 이렇게 변수를 지정하는 것을 쓰래기 값 (garbage
value)라고 합니다. 당장은 어떤 값을 넣을지는 모르지만 나중에 값을 달라는 의미라고 합니다. 쓰래기 값 말고 또 
do while 문이 있었습니다. 이것도 루프문인데 전에 배웠던 보통 while 문이나 for 문 과는 어떤 차이가 있을까요? 차이점은 do while문에서는 
do 안에 있는 명령을 일단 한번 실행한 후 반복을 결정하고 보통 while문은 먼저 반복을 결정한 후 명령을 실행하는 차이입니다. 
그래서 위 예시에서는 처음 한번의 입력 질문을 받을 수 있었고 거기서 1이상의 수를 적어 반복에서 빠져나올수 있었습니다.
다음은 중첩 루프의 예시입니다.
#include <cs50.h>
#include <stdio.h>

int main(void)
{
    int n;

    do
    {
        n = get_int("Size: ");
    }
    while (n < 1);

    for (int i = 0; i < n; i++)
    {
        for (int j = 0; j < n; j++)
        {
            printf("#");
        }
        printf("\n");
    }
}

이 코드는 우선 "size: "라는 질문이 출력되고 1이상의 값이면은 밑의 명령이 실행될것입니다. 이 명령부분이 중첩 루프 입니다. for문의 명령부분에 
다시 for문이 있습니다. 이러면 안쪽의 for문이 입력받은 n번 만큼 #을 반복하여 출력하고 줄 바꿈 한 값을 다시 n번 반복하게 됩니다.그 결과 
입력값 n번만큼의 행과 열의 #으로 이루어진 모형이 출력됩니다. 이렇게 루프문을 중첩시켜서 사용할 수 있습니다.


하드웨어의 한계성 - 저는 막연히 컴퓨터는 항상 정확하고 완전무결한 무엇인가 라고 생각 했던거같습니다. 하지만 컴퓨터도 물질로 이루어진 하드웨어에 
불과 합니다. 무엇이든 할 수 있을거 같은 컴퓨터지만 결코 무한한 숫자를 세지 못할 것입니다. 그래서 이번에 하드웨어의 한계에 대해 알아보겠습니다.
#include <cs50.h>
#include <stdio.h>

int main(void)
{
    // 사용자에게 x 값 받기
    float x = get_float("x: ");

    // 사용자에게 y 값 받기
    float y = get_float("y: ");

    // 나눗셈 후 출력
    printf("x / y = %.50f\n", x / y);
}
이런 코드가 있다고 할때 x값으로 1을 주고 y값으로 10을 줘 봤습니다. 당연히 값은 0.1 이 나와야 할 것입니다. %.50f 이렇게 표현 했으니 0.1뒤로 0이 
소수점 아래 50개 까지 이어져야합니다. 하지만 실재 실행값은 
x / y = 0.10000000149011611938476562500000000000000000000000
이렇게 나왔습니다. 이 결과는 아주 이상합니다. 제가 알고있던 수학이 거짓말이었던지 컴퓨터가 거짓말을 하고 있는 것일 겁니다. 
사실 이유는 메모리가 한정되어있어서 입니다. 메모리는 얼마나 큰 메모리라하더라도 결국은 한계가 있습니다. 그러면 부동 소수점에서 소수점 아래로 
얼마든지 내려갈 수 있는데 이 한정된 메모리는 모든 경우의 수의 부동소수점까지 전부 기억하고 있을까요? 그것이 가능 할까요? 아닐 것입니다. 
모든 부동 소수점을 세려고 하다가는 0에서 1까지의 소수점만 세더라도 무한에 가까운 메모리가 필요할것입니다. 그래서 1 나누기 10 이라는 아주 간단한 
문제를 표현할때도 이런 오류가 발생합니다. 저장된 값중에 1나누기 10의 소수점아래 50개까지 가장 가까운 수를 출력 한 것일 겁니다.
부동 소수점에서만 이런 문제가 발생 할까요? 정수에서도 이런 문제는 발생합니다.이런 코드가 있습니다.
#include <stdio.h>
#include <unistd.h>

int main(void)
{
    for (int i = 1; ; i *= 2)
    {
        printf("%i\n", i);
        sleep(1);
    }
}
for문에서 컨디션 부분을 비워 항상 true인 상태로 하여 무한히 반복하도록 하는 반복문입니다. 변수 i는 1의 값부터 시작하여 반복할 때 마다 2를 곱해나갈
것입니다. 아래의 sleep()함수는 unistd라이브러리에 있는 함수입니다. 괄호안의 숫자만큼의 초 를 지연시키는 역할을 합니다. 이 프로그램을 실행하면 결과는 
이렇습니다.
...
1073741824
overflow.c:6:25: runtime error: signed integer overflow: 1073741824 * 2 cannot be represented in type 'int'
-2147483648
0
0
...
1073741824이라는 값부터 에러가 떳습니다. int 타입에서는 이 이상 표현할 수 없다고 하는거 같습니다. 이후 0 이라고 이어지는데 이것도 
수학적으로 거짓말이라서 2제곱을 해나갈 때 일정수 이상 부터는 0인게 아닐 겁니다. int에서는 32개의 비트가 다였기 때문입니다. 
그 이상의 숫자는 저장할 수 없는 것입니다.
이런 오버플로우 문제는 실생활에서도 종종 발견됩니다.
1999년에 큰 이슈가 되었던 Y2K 문제는 연도를 마지막 두 자리수로 저장했던 관습 때문에 새해가 오면 ‘99’에서 ‘00’으로 정수 
오버플로우가 발생하고, 새해가 2000년이 아닌 1900년으로 인식된다는 문제였습니다.그리고 세계는 수백만 달러를 투자해서 프로그래머들에게 더 많은 
메모리를 활용해서 이를 해결하도록 하였습니다.이는 통찰력 부족으로 발생한 아주 현실적이고 값비싼 문제였습니다.