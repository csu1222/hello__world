<CS50> 데이비드 j.말란

  1강 컴퓨팅 사고 
컴퓨터사이언스의 개론?에 대한 강의인 cs50에서 첫 강의로 컴퓨팅적인 사고를 주제로 삼았습니다. 강의 순서는
1) 2진법
2) 정보의 표현
3) 알고리즘 
4) 스크래치(비주얼적으로 표현된 코딩 학습도구)
이렇게 4파트로 이루어져 있었습니다. 

1-1 2진법 - 우선 2진법에 대한 이야기는 컴퓨터의 기본 요소이기 때문에 첫 주제로 삼으신거 같습니다.
제가 살아가면서 정확한 이유는 모르지만 얼핏 듣기로는 컴퓨터는 0과 1로 이루어져있다고 듣고는 했습니다. 예전 crashcourse 라는 
유튜브 채널의 컴퓨터 사이언스 강의들을 들은적이 있습니다. 이 cs50강의에서도 언급하였던 것이 컴퓨터의 기본 단위가 트랜지스터 라는 
것이었습니다. 트랜지스터라는 온 오프 상태를 나타낼수 있는 것으로 트랜지스터를 잘 이용하여 2진법으로 표현할 수 있고 또 불리언 값
true는 1, false는 0 라고 간주하여 표현하기도 합니다. 그리고 몇개의 트랜지스터를 알맞게 연결하여 논리회로를 표현하고 , 
더욱 많은 0과 1로 일종의 주소를 만들어 RAM이나 ROM 같은 저장공간, 또 CPU자체가 이런것들을 모아놓은 두뇌라고 들었습니다.
이런 것들을 대략적으로 말하여 컴퓨터가 0과 1로 이루어져 있다 라는 이야기인것 같습니다.

1-2 정보의 표현 - 0과 1로 이루어진 컴퓨터에서 숫자는 2진법을 10진법으로 해석 가능할 것입니다. 하지만 2진법인 숫자를 어떻게 
문자, 이미지, 소리 등을 표현할 수 있을까요? 수십년전 0과 1로 알파벳같은 문자를 표현하기위해 일종의 약속을 하였습니다. "2진법으로 
몇번이라고 하면 이것은 이 알파벳 이야!" 라는 식으로 말입니다. 이것을 ASCII 아스키코드라고 합니다.
American Standard Code for Information Interchange 의 약자인데요 이름에서도 보이듯이 미국에서 정한 기준입니다. 하지만 요즘은 
단순히 알파벳정도만 쓰는정도가 아니죠 여러 나라의 문자도 있고 기본적으로 🤣이런 이모지 도 내장되어있는 새로운 기준을 씁니다.
이 기준의 이름은 Unicode라는 이름입니다. 문자는 이렇게 하나씩 코드를 나열하여 표현한다고 하고 이미지 같은 경우는 어떨까요
다들 픽셀이라는 말을 들어봤을 것입니다. 컴퓨터나 스마트폰 태블릿PC등 디지털 디바이스에서 이미지나 화면의 해상도를 말할때 
픽셀이 얼마나 많느냐 라고 합니다. 이미지를 이루는 픽셀들에 컴퓨터는 2진법으로도 좌표를 지정 할수 있을 것입니다. 또 RGB이라는 
빨강,초록,파랑 이라는 빛의 3원색을 어떻게 조합하느냐로 색을 지정할 수도 있을것입니다. 그러면 하나하나 지정된 좌표의 픽셀이 
어떠한 색이라고 지정한다면 이 픽셀들을 쌓아 하나의 이미지로 보이게 할 수도 있을 것입니다. 이것은 사실 지금 쓰고 있는 텍스트에도 
적용되는 사항입니다 . 이 텍스트도 단색으로 표현된 이미지라고 할 수도 있기때문입니다.😁 소리, 음악, 영상은 어떻게 표현할까요? 
일단 영상의 경우 이미지의 연장선상에 있습니다. 여러 연결된 이미지를 빠르게 보여주는것이 영상입니다. 뇌가 충분히 정지된 이미지를 
움직이고 있다고 착각할 만큼 빠르게 보여주면 되는것이었습니다. 음악, 소리는 같은 원리인데요 소리는 시간에따라 크기, 음계를 진동수
에 하나 하나 숫자를 대입하여 저장 할 수있습니다.

1-3 알고리즘 - 위에서 정보를 입력하는 방식을 배웠습니다. 하지만 컴퓨터는 단순히 정보를 입력하는 것만 할수 있는게 아니죠 
입력한 정보를 어떠한 과정을 거쳐 원하는 출력값으로 받을 수 있습니다. 지금 말한 어떠한 과정이 알고리즘이라고 할 수 있을것 입니다.
알고리즘은 입력값을 출력값의 형태로 바꾸기 위해 어떤 명령들이 수행 되어야 하는지에 대한 규칙들의 순서적 나열입니다.
좋은 알고리즘의 요건에는 정확함과 효율적임이 있어야 할 것입니다. 정보를 가공하는데에 있어 정확한 값이 나오도록 명령들을 나열해야 
할 것이고, 효율적인 명령들로 정보를 가공해야 컴퓨터의 리소스를 절약하여 성능적으로 많은 이득을 봐야 할 것입니다.
예를 들면 탐색하는 알고리즘으로 100페이지의 전화번호부에 천성욱 이라는 이름을 찾는다고 하면 일단 맨 첫페이지 부터 한장씩 찾아보는 방법
이 하나 있을것이고 혹은 전화번호부의 중간을 펼쳐서 이름이 있는지 확인하고 절반의 앞이나 뒤쪽중 해당하는 곳에 절반을 다시 열어보고를 
반복하여 찾는 방법도 있을 것입니다. 둘다 시간을 들이면 확실히 이름이 어디있는지 찾을 수 있을것입니다 이름이 처음부터 전화번호부에 없지만
않다면요. 두 방법다 알고리즘으로써 정확성은 갖추고 있다고 할 수 있겠습니다. 그렇다면 어느 쪽이 효율적인가 살펴보면 첫번째 방법은 
가장 오래걸리는 경우 100페이지를 전부 봐야합니다. 반면 두번째 절반 씩 찾아보는 경우 첫시도에 50페이지, 두번째에 25페이지, 세번째에 12나 
13페이지, 네번째에 6페이지 정도, 다섯번째에 3페이지, 여섯번째에 2페이지 , 일곱번째에 1페이지 가 남는 가장 오래걸리는 경우에 일곱정도에 
찾을수 있을 것입니다.최대 100번의 시도와 7번의 시도 어느 쪽이 효율적인가요 이런식으로 같은 결과를 내고 같은 정확성을 가진 알고리즘이지만 
효율성에는 차이가 있을수 있습니다. 또 이런 알고리즘을 프로그래밍적이면서 사람의 언어로 적어보는 것을 의사코드라고 합니다.예를 들면
1.전화번호부를 집는다.
2.전화번호부의 중간을 펼친다.
3.페이지를 확인한다
4.만약 찾는 이름이 있다면
5.  그 번호로 전화한다.
6.만약 찾는 이름이 절반의 페이지중 앞쪽에 있다면
7.  전화번호부의 앞쪽 절반을 펼친다.
8.  3번째 줄의 명령으로 간다.
9.만약 찾는 이름이 절반의 페이지중 뒷쪽에 있다면
10. 전화번호부의 뒷쪽 절반을 펼친다.
11. 3번째 줄의 명령으로 간다.
12.이도 저도 아니면
13.행위를 중지한다.
이렇게 적는 것이 의사코드입니다. 

  2강 C언어
C언어는 현재까지 사용되는 언어중 매우 오래된 언어에 속하고 또 로우레벨의 언어 컴퓨터 언어에 가까운 언어라고 합니다.
파이썬이나 자바스크립트 같은 언어는 보다 사람 친화적인 언어 하이레벨 언어라고도 불리는데 이때 로우레벨 하이레벨은 
뭐가 더 좋고 나쁜것이 아닙니다. 로우레벨은 기계친화적이고 사람이 배워 사용하기 어려운 언어이지만 속도나 성능은 하이레벨언어에
비해 좋습니다. 하이레벨의 언어는 반대로 배우기쉬운 언어지만 상대적으로 속도가 느립니다. 현대의 컴퓨터는 컴퓨터자체의 
연산속도가 매우 빠르다 보니 이 언어끼리의 속도차이는 생각보다 중요하지 않을 수 있지만 컴퓨터프로그램 중에서도 속도가 중요한 게임
같은데서는 C언어 계열을 사용하고 pc가 아닌 에어컨이나 공장용 혹은 농장에서 사용하는 기계에 들어가는 컴퓨터의 경우 pc만큼의
속도나 메모리가 없기때문에 C언어의 속도나 성능이 필요합니다. 이렇게 용도가 다를뿐 하이 로우 라고 급의 차이는 없습니다.
C언어나 프로그래밍 언어를 배우면서 가장 처음 해보는 것에 hello, world!를 출력해볼텐데요 
#include <stdio.h>

int main(void){
  printf("hello, world!");
}
이런 코드가 됩니다. 첫째 줄에 include한 stdio.h는 printf함수를 사용하기위한 라이브러리 라고 합니다. 파이썬의 경우 단순히
print("hello, world!")
이렇게 간결한 코드로 같은 명령을 내릴수 있습니다. 이런 차이가 로우레벨과 하이레벨언어의 차이점일 것입니다.

"hello, world!"같이 큰 따옴표 안에 하나 이상의 문자가 적혀있으면 이 데이터는 문자열이라는 자료형입니다. 자료형에는 문자열, 정수,
실수, 불리언등 여러 자료형이 있습니다.

사용자 정의 함수 - C언어에서 사용자 정의 함수를 만드는 방법을 학습해 보겠습니다. cough라는 텍스트를 콘솔에 출력하는 함수입니다. 

#include <stdio.h>

void cough(void)
{
  printf("cough\n");
}

int main(void)
{
  for (int i = 0; i < 3; i++){
    cough();
  }
}

이 코드는 cough를 3번 출력해주는 코드입니다. 실제 작동하는 main함수에서 사용자 정의 함수인 cough함수를 for 문으로 3번 반복 실행 했습니다.
작동을 하긴 하지만 메인함수가 밑에 있으면 나중에 사용자 정의 함수가 많아지면 가독성이 떨어질 수 있으니 한번 cough함수를 메인 함수 밑으로 옯겨 봤습니다.

#include <stdio.h>

int main(void)
{
  for (int i = 0; i < 3; i++){
    cough();
  }
}

void cough(void)
{
  printf("cough\n");
}

이렇게 코드를 컴파일 하면 오류가 발생합니다. 메인함수안에 cough()라는 함수를 찾을 수 없다는 말인데 이렇게 C언어에서는 코드가 위에서 아래로 왼쪽에서 오른쪽으로
순서대로만 실행되기떄문에 밑에 사용자 정의 함수를 정의 하기전에 먼저 사용하여 오류가 발생하였습니다. 이럴때 어떠한 테크닉을 쓰면 해결이 된다고 합니다.

#include <stdio.h>

void cough(void);

int main(void)
{
  for (int i = 0; i < 3; i++){
    cough();
  }
}

void cough(void)
{
  printf("cough\n");
} 

이렇게 일단 위에 이름만이라도 함수를 정의 해놓으면 메인 함수에서 실행할때 이런 이름의 함수가 있기는 하다는 듯이 코드 끝까지 읽고 실행이 됩니다.
맨위에 한줄로 적어놓은 간이 함수를 프로토 타입이라고 부릅니다. 이번엔 cough를 for루프로 감싸지 말고 함수 자체에 매개변수를 주어 반복 실행 하고 
싶습니다.

void cough(int n)
{
  for (int i; i < n; i++)
  {
    printf("cough\n");
  }
}

이런 함수를 만들면 함수의 괄호안에 반복하고 싶은 만큼의 정수를 적으면 숫자 만큼 기침을 반복하는 기능을 구현한 것입니다. 이런 기능을 구현하고 
다른 사용자는 이 함수를 사용하면 자세한 구현 방법은 몰라도 직관적으로 기침을 출력해주는 함수고 괄호에는 반복할 정수를 적으면 되겠구나 라고 
알 것입니다. 추상화의 영역입니다. 제가 프로그래밍으로 서비스를 만들며 기능을 구현 할 때 다른 프로그래머가 먼저 만들어놓은 코드들을 가져와서 
쓰는것은 아주 흔한일입니다. 하지만 그렇게 가져와서 쓸때 마다 어떻게 구현됐는지 원리를 하나하나 알아야한다면 작업속도가 매우 느려질 것입니다.
그렇다고 코드의 의미를 알려고 하는것 자체가 잘못된 행동은 아닐겁니다. 오히려 공부가 되면 됐지 다만 비지니스 적으로 효율성을 따지면 별로 좋은
태도가 아닐 것이라는 이야기입니다. 
다음은 조금 다른 사용자 정의 함수 입니다.
#include <cs50.h>
#include <stdio.h>

int get_positive_int(void);

int main(void)
{
    int i = get_positive_int();
    printf("%i\n", i);
}

int get_positive_int(void)
{
    int n;
    do
    {
        n = get_int("Positive Integer: ");
    }
    while (n < 1);
    return n;
}
이번에 CS50 라이브러리도 인클루드했고 프로토타입 함수와 밑에 사용자정의 함수 앞에 int라고 선언 되어있습니다. 이전 까지는 
void function(void) 이런 식이었는데요 이 의미는 앞이 void 이면 함수가 어떤 값을 받아 반환되는게 아닌 경우 입니다.
cough 함수도 printf를 실행했을 뿐 함수가 어떤 값을 반환한것은 아니었습니다. 그러면 이번 get_positive_int 함수는 어떤 기능을 구현 한것
이나면 우선 아무 값이 없는 정수를 받을 수있는 변수 n을 선언합니다. 그 후 do while 문은 우선 do{}에 있는 명령을 실행한 후 while의 
불리언 값에 의해 do{}의 명령이 다시 루프 할지 확인하는 문법입니다. 그러면 do에서 get_int로 어떤 정수값을 입력 받습니다. 질문은 
양의 정수를 달라고 하는군요 그 값을 변수 n에 담습니다. 이제 while로 반복할지 안할지 체크 합니다. n에 저장된 값이 정수 1보다 
작으면 반복합니다. 1이상인 숫자를 입력할때까지. 새로운 개념들이 몇개 있었습니다. int n 이렇게 변수를 지정하는 것을 쓰래기 값 (garbage
value)라고 합니다. 당장은 어떤 값을 넣을지는 모르지만 나중에 값을 달라는 의미라고 합니다. 쓰래기 값 말고 또 
do while 문이 있었습니다. 이것도 루프문인데 전에 배웠던 보통 while 문이나 for 문 과는 어떤 차이가 있을까요? 차이점은 do while문에서는 
do 안에 있는 명령을 일단 한번 실행한 후 반복을 결정하고 보통 while문은 먼저 반복을 결정한 후 명령을 실행하는 차이입니다. 
그래서 위 예시에서는 처음 한번의 입력 질문을 받을 수 있었고 거기서 1이상의 수를 적어 반복에서 빠져나올수 있었습니다.
다음은 중첩 루프의 예시입니다.
#include <cs50.h>
#include <stdio.h>

int main(void)
{
    int n;

    do
    {
        n = get_int("Size: ");
    }
    while (n < 1);

    for (int i = 0; i < n; i++)
    {
        for (int j = 0; j < n; j++)
        {
            printf("#");
        }
        printf("\n");
    }
}

이 코드는 우선 "size: "라는 질문이 출력되고 1이상의 값이면은 밑의 명령이 실행될것입니다. 이 명령부분이 중첩 루프 입니다. for문의 명령부분에 
다시 for문이 있습니다. 이러면 안쪽의 for문이 입력받은 n번 만큼 #을 반복하여 출력하고 줄 바꿈 한 값을 다시 n번 반복하게 됩니다.그 결과 
입력값 n번만큼의 행과 열의 #으로 이루어진 모형이 출력됩니다. 이렇게 루프문을 중첩시켜서 사용할 수 있습니다.


하드웨어의 한계성 - 저는 막연히 컴퓨터는 항상 정확하고 완전무결한 무엇인가 라고 생각 했던거같습니다. 하지만 컴퓨터도 물질로 이루어진 하드웨어에 
불과 합니다. 무엇이든 할 수 있을거 같은 컴퓨터지만 결코 무한한 숫자를 세지 못할 것입니다. 그래서 이번에 하드웨어의 한계에 대해 알아보겠습니다.
#include <cs50.h>
#include <stdio.h>

int main(void)
{
    // 사용자에게 x 값 받기
    float x = get_float("x: ");

    // 사용자에게 y 값 받기
    float y = get_float("y: ");

    // 나눗셈 후 출력
    printf("x / y = %.50f\n", x / y);
}
이런 코드가 있다고 할때 x값으로 1을 주고 y값으로 10을 줘 봤습니다. 당연히 값은 0.1 이 나와야 할 것입니다. %.50f 이렇게 표현 했으니 0.1뒤로 0이 
소수점 아래 50개 까지 이어져야합니다. 하지만 실재 실행값은 
x / y = 0.10000000149011611938476562500000000000000000000000
이렇게 나왔습니다. 이 결과는 아주 이상합니다. 제가 알고있던 수학이 거짓말이었던지 컴퓨터가 거짓말을 하고 있는 것일 겁니다. 
사실 이유는 메모리가 한정되어있어서 입니다. 메모리는 얼마나 큰 메모리라하더라도 결국은 한계가 있습니다. 그러면 부동 소수점에서 소수점 아래로 
얼마든지 내려갈 수 있는데 이 한정된 메모리는 모든 경우의 수의 부동소수점까지 전부 기억하고 있을까요? 그것이 가능 할까요? 아닐 것입니다. 
모든 부동 소수점을 세려고 하다가는 0에서 1까지의 소수점만 세더라도 무한에 가까운 메모리가 필요할것입니다. 그래서 1 나누기 10 이라는 아주 간단한 
문제를 표현할때도 이런 오류가 발생합니다. 저장된 값중에 1나누기 10의 소수점아래 50개까지 가장 가까운 수를 출력 한 것일 겁니다.
부동 소수점에서만 이런 문제가 발생 할까요? 정수에서도 이런 문제는 발생합니다.이런 코드가 있습니다.
#include <stdio.h>
#include <unistd.h>

int main(void)
{
    for (int i = 1; ; i *= 2)
    {
        printf("%i\n", i);
        sleep(1);
    }
}
for문에서 컨디션 부분을 비워 항상 true인 상태로 하여 무한히 반복하도록 하는 반복문입니다. 변수 i는 1의 값부터 시작하여 반복할 때 마다 2를 곱해나갈
것입니다. 아래의 sleep()함수는 unistd라이브러리에 있는 함수입니다. 괄호안의 숫자만큼의 초 를 지연시키는 역할을 합니다. 이 프로그램을 실행하면 결과는 
이렇습니다.
...
1073741824
overflow.c:6:25: runtime error: signed integer overflow: 1073741824 * 2 cannot be represented in type 'int'
-2147483648
0
0
...
1073741824이라는 값부터 에러가 떳습니다. int 타입에서는 이 이상 표현할 수 없다고 하는거 같습니다. 이후 0 이라고 이어지는데 이것도 
수학적으로 거짓말이라서 2제곱을 해나갈 때 일정수 이상 부터는 0인게 아닐 겁니다. int에서는 32개의 비트가 다였기 때문입니다. 
그 이상의 숫자는 저장할 수 없는 것입니다.
이런 오버플로우 문제는 실생활에서도 종종 발견됩니다.
1999년에 큰 이슈가 되었던 Y2K 문제는 연도를 마지막 두 자리수로 저장했던 관습 때문에 새해가 오면 ‘99’에서 ‘00’으로 정수 
오버플로우가 발생하고, 새해가 2000년이 아닌 1900년으로 인식된다는 문제였습니다.그리고 세계는 수백만 달러를 투자해서 프로그래머들에게 더 많은 
메모리를 활용해서 이를 해결하도록 하였습니다.이는 통찰력 부족으로 발생한 아주 현실적이고 값비싼 문제였습니다.

  3강 배열

1) 컴파일링 - 제가 위에서 코드를 작성하고 컴파일해왔지만 컴파일은 4가지 프로세스를 줄여서 간략하게 말한 것이었습니다.
prepocessing, compiling, assembling, linking의 4단계입니다. 순서대로 prepocessing 전처리 단계부터 살펴보겠습니다. #으로 시작되는 C소스코드는 
전처리기에게 실질적인 컴파일이 이루어지기 전에 무언가를 실행하라고 알려줍니다. 예를 들어, #include는 전처리기에게 다른 파일의 내용을 포함시키라고
 알려줍니다. 프로그램의 소스 코드에 #include 와 같은 줄을 포함하면, 전처리기는 새로운 파일을 생성하는데 
 이 파일은 여전히 C 소스 코드 형태이며 stdio.h 파일의 내용이 #include 부분에 포함됩니다.
다음의 compiling은 보통 소스코드에서 머신코드로 바꿔주는 것을 말합니다. 사실 C언어에서 어셈블리 언어라는 것으로 바꿔주는 단계라고 합니다.
그리고 세번째 단계인 assembling이라는 단계가 이 어셈블리 언어로 이루어진 코드를 0과1로 이루어진 머신코드로 바꾸주는 단계입니다. 
이다음으로 linking의 단계가 한 C파일에서 사용돤 여러 코드들을 하나로 뭉쳐주는 단계라고 합니다. include된 파일들을 하나로 뭉쳐 a.out이나 
개발자가 정의한 이름의 파일로 합쳐주는 겁니다. 
그래서 이 4단계를 뭉뚱그려서 컴파일 한다라고 부릅니다.

2) 디버깅 - 버그는 프로그래머라면 필연적으로 경험할 수 밖에 없을 것입니다. 코드작성후 작성한 코드의 디버깅을 하는 것은 매우 자연스러운 일의 
순서입니다. 버그와 디버깅이라는 단어는 실제로 벌레가 컴퓨터에 들어가서 오류를 일으켰던 일화에서 시작된 단어입니다. 현대의 컴퓨터는 손안에 들어오
는 크기의 스마트폰 까지 작아져 있어 실제 벌레가 어떻게 컴퓨터에 들어가는지 이해가 안가실 겁니다. 하지만 초기의 컴퓨터는 트랜지스터가 발명되지 
않았던 시대에도 존재 했습니다. 그 시절에는 진공관같은 걸로 0과 1을 표현하였죠 그래서 아무리 컴퓨터를 소형화 하고 싶어도 거의 방하나를 차지하는
크기였던 시절도 있습니다. 그렇게 거대한 컴퓨터라면 실제 벌레가 들어가 오류를 일으키는건 상상할수 있을 겁니다. 
보통 프로그래머는 IDE라는 통합 개발 환경에서 개발을 하는데 IDE에는 디버깅 도구가 대부분있을것입니다. 디버깅 도구는 어떤 방법으로 프로그래머가
디버깅 하는것을 도와 줄까요 컴퓨터에서 코드가 실행되는 속도가 너무 빠르기 때문에 사람이 실시간으로 실행되는 프로그램의 버그를 인식하는 것은 
불가능 하다고 생각합니다. 그래서 디버깅 도구는 프로그램을 특정 행에서 멈울 수 있게 해줍니다. 이 멈추는 지점을 중지점 이라고 합니다. 
이 중지점에서부터 프로그램이 한번의 프로세싱 하나씩 천천히 살펴보며 프로그램을 실행해 나갈수 있게 해줍니다.

3) 코드의 디자인 - 실제 업무에서 프로그래머 혼자서 모든 코드를 짜는것은 드문 일입니다. 대부분 여러 동료와 함께 협업을 합니다. 이사람 저사람이
모두 같은 코드를 보며 자신이 담당한 부분의 개발을 해나가는데 그래서 코드를 한 프로그래머가 자신만의 형식으로 작성 하면 같이 협업하는 사람들이 
서로 코드를 이해하는데 많은 어려움을 격을 것입니다. 가령 나중에 합류하게된 신입 프로그래머도 팀에서 이미 적어두었던 코드를 이해하는것을 위해서도
코드를 보기쉽게 또 주석을 충분히 사용해 이해하기 쉽게 작성해야 할 것입니다. 
디버깅을 하면서 분명히 막히는 순간이 올것입니다. 아무리 다시 확인하고 구글링도 해보고 해결하려고 멍하니 모니터만 처다보기도 할 것입니다. 
그럴땐 그냥 잠깐 휴식을 하는것도 한 방법입니다. 저도 어떤 오류가 발생하고 해결하려다 시간이 늦어 일단 잠에 들었더니 일어나서 문뜩 
해결방법이 떠오른 경험이 있습니다. 그저 신앙적인 방법론이 아닌 우리 뇌는 자기전 까지 고민했던 문제를 자는동안에 다시 반추해봤던겁니다. 
또 CS50 강의에서 러버덕 디버깅 이라고 하는 방법도 알려주었습니다. 그저 고무오리를 한마리 준비해두고 어떤 문제에 막혔을 때 그 오리에게 
어떤 문제인지 설명해보는 겁니다. 머리속으로 문제에 대해 생각하는것과 남에게 설명하기위해 언어적으로 풀어서 말하며 자신의 귀로도 다시 
듣게되면 일종의 객관적인 관점에서 문제를 바라볼수 있게 되어 문제 해결에 도움이 될 수도 있는 방법론 입니다.

4) 배열 - C언어에는 여러 종류의 데이터형 data type 이 있습니다. bool, char, int, float, long, double, sting 등 이외에도 여러 
데이터 타입이 있습니다. 그리고 변수를 선언할 때 마다 그 변수의 데이터 타입을 선언해야 하는데 각각 데이터 타입마다 다른 크기의 메모리를 점유
하게 됩니다. 예를 들면 bool, char는 1byte의 크기를 가지고 int, float는 4byte의 크기를 가지는 등 메모리를 점유한다는 말이 무슨 의미이냐면
실제 사용하는 컴퓨터들에는 RAM이라고 하는 휘발성 메모리가 있습니다. 1GB,2GB,4GB등등 여러 용량의 RAM이 사용되고 있는데 이 작은 RAM은 
1bit를 나타내는 트랜지스터가 8개 모여서 1byte의 묶음이 되고 또 이 byte들이 약 1천개 모여 kb 킬로바이트가 됩니다. 이렇게 메가바이트, 기가바이트
까지 합쳐놓은게 실제 RAM의 구조일것입니다. 그러면 컴퓨터에서 하나의 변수를 선언해보면 데이터 타입은 불리언 이라고 쳐봅시다. 그러면 RAM의 어느 
한 byte에 제가 정의한 변수의 값이 할당되는 것입니다. 이렇게 소프트웨어로만 생각하면 막연히 무한할것 같았던 저장 용량이 물리적으로 한계가 있을 
수 밖에 없습니다. 
어떤 예시를 들어보겠습니다. 
#include <stdio.h>

int main(void)
{
  char c1 = 'H';
  char c2 = 'I';
  char c3 = '!';
  printf("%c %c %c\n", c1, c2, c3);
}
// 실행결과 : H I !
이 예시에서 몇가지 새로운 사실을 알 수 있습니다. 제가 string타입의 변수를 입력 할 때는 큰따옴표""를 사용해서 선언 했지만 char타입의 변수에서는
작은따옴표''를 사용했습니다. 어떤 원리가 있는것은 아니고 C언어를 만들때 그냥 정한 규칙인겁니다. 
실행결과인 H I !를 얻기위해 사용된 세가지 변수는 RAM의 1byte짜리 공간은 각각 한개씩 할당되었습니다. 
조금 다른 얘기지만 printf에서 %c는 char타입을 불러올때 쓰는 명령어 였습니다. 여기서 H라는 문자 하나는 정말 알파벳으로 컴퓨터에 저장 되어있었나요?
아닙니다. ASCII코드에서 정한 10진법의 숫자에 하나의 알파벳씩 할당되어 있습니다. 그걸 불러온것이죠 그럼 만약 이러면 어떻게 될까요
printf("%i %i %i", (int)c1, (int)c2, (int),c3); // 실행결과 : 72 73 33
이렇게 변수앞에 (데이터 타입)변수 이런 형식으로 쓰면 형변환이 됩니다. 실행결과는 실제 값인지 확실하지않은 제 임의의 값입니다.
컴파일러에 따라 괄호안의 데이터 타입은 생략 될 수도 있다고 합니다.
다시 다른 예시를 들어보겠습니다.
#include <cs50.h>
#include <stdio.h>

int main(void)
{
    // Scores
    int score1 = 72;
    int score2 = 73;
    int score3 = 33;

    // Print average
    printf("Average: %i\n", (score1 + score2 + score3) / 3);
}
어떤 학생의 점수를 평균내는 코드입니다. 이 코드는 약간의 문제점이 있다고 할 수 있습니다. 확장성, int에서만 표현할 수 있다는점, 반복되는 코드가 
있다는 점등 몇몇 문제가 있죠 그 중 코드가 반복되어 사용되는 점에 집중해보겠습니다. score라는 이름의 변수이름이 반복되고있습니다. 이 
변수들은 각각의 점수라는 의미에서 서로 공통점이 있습니다. 하지만 지금 처럼 표현해서는 각각 변수의 이름을 외우고 있어야지만 필요한 데이터를 
찾을 수 있을 겁니다. 이 공통점이 있는 값들을 하나로 뭉쳐서 관리하면 더욱 관리하기 쉽겠죠.
#include <cs50.h>
#include <stdio.h>

int main(void)
{
    // Scores
    int scores[3];
    scores[0] = 72;
    scores[1] = 73;
    scores[2] = 33;

    // Print average
    printf("Average: %i\n", (scores[0] + scores[1] + scores[2]) / 3);
}
이 코드에서 새로운 문법이 등장하였는데 바로 배열 array입니다. int scores[3]; 라는 코드의 의미는 정수타입이고 배열의 이름은 scores입니다.
중괄호 []안의 숫자는 이 배열의 내용물이 몇개나 되니까 이만큼의 저장공간은 내어 달라는 의미죠. 이 3개의 공간이 있는 배열은 0, 1, 2 이런식으로 
순서 index가 정해집니다. 그래서 scores[0] = 72; 라는 코드는 scores배열의 첫번째 자리에 72라는 정수를 저장한다는 의미가 됩니다.

하지만 아직 이 코드는 어딘가 이상합니다. 배열의 크기를 정하는 3과 점수의 평균을 낼 때 사용한 3은 같은 의미를 가지죠 배열의 저장된 점수들의 
총 갯수 입니다. 지금은 이 두개가 같은 의미라는 것을 알지만 언젠가 다시 이 코드를 봤을 때 각각 3 이라는 것 말고 연관성을 떠올리려면 코드 전체를 
다시 살펴야 할것입니다. 이런 상황을 개선하는 방법으로 전역 변수 grobal variable가 있습니다. 예시입니다.
#include <cs50.h>
#include <stdio.h>

const int N = 3;

int main(void)
{
    // 점수 배열 선언 및 값 저장
    int scores[N];
    scores[0] = 72;
    scores[1] = 73;
    scores[2] = 33;

    // 평균 점수 출력
    printf("Average: %i\n", (scores[0] + scores[1] + scores[2]) / N);
}
함수 밖에 N이라는 변수를 선언 했습니다. 이러면 함수안에서만 쓰이는 변수가 아닌 이 파일 전체에 적용되는 변수가 됩니다. 전역 변수이죠
또 int 앞에 const 라는 명령어가 새롭습니다. 상수 constant 라는 의미로 이 N이라는 변수는 실수로라도 값이 변하지 않게끔 고정 시켜줍니다.
변수이름이 대문자로 적히는 것은 프로그래밍적 의미는 없고 그냥 관습이라고 합니다. 
scores의 크기로 전역 변수를 선언하였기 때문에 점수 개수가 바뀌었을때 수정해야 하는 코드가 조금 줄었습니다.
하지만 여전히 일일이 배열의 인덱스마다 점수를 지정해줘야 하는 불편함이 있습니다. 새로운 점수의 평균을 내고 싶을때 저는 다시 이 코드를 열어
과목의 갯수와 각각의 점수를 해당 위치에 적어야 할 것입니다. 저는 더욱 이 프로그램이 동적으로 움직였으면 좋겠습니다.

#include <cs50.h>
#include <stdio.h>

float average(int length, int array[]);

int main(void)
{
    // 사용자로부터 점수의 갯수 입력
    int n = get_int("Scores:  ");

    // 점수 배열 선언 및 사용자로부터 값 입력
    int scores[n];
    for (int i = 0; i < n; i++)
    {
        scores[i] = get_int("Score %i: ", i + 1);
    }

    // 평균 출력
    printf("Average: %.1f\n", average(n, scores));
}

//평균을 계산하는 함수
float average(int length, int array[])
{
    int sum = 0;
    for (int i = 0; i < length; i++)
    {
        sum += array[i];
    }
    return (float) sum / (float) length;
}

점수들의 평균을 내는 코드를 더욱 동적으로 만들어본 코드입니다. 우선 배열의 길이를 get_int함수로 입력받았죠 get_int는 CS50 강의에서 미리 만들어놓은
라이브러리의 함수입니다. 그리고 배열의 길이만큼의 횟수만큼 점수들을 물어봅니다. for문으로 구현되어 있습니다. 
그리고 점수들의 평균을 내는 함수를 따로 사용자 정의 함수로 만들었습니다. 평균은 대부분 부동소수점일 테니까 float의 타입으로 리턴 받습니다.
함수에 두개의 인수를 받는데요 C에서는 배열의 길이를 따로 기억하고 있지 않기 때문에 배열의 길이와 배열 자체를 인수로 받아야 했습니다.
그리고 다음으로 눈여겨 봐야할 곳은 sum을 배열의 길이로 나누면 정수나누기 정수 입니다. C에서는 int 끼리 연산을 하면 그 값도 int형이 나옵니다.
이러면 정확한 평균값을 얻을 수 없습니다. 그래서 return 뒤로 sum과 길이를 (float)로 형변환 해주었습니다. 
그 다음 코드 상단에 평균을 내는 함수의 프로토타입을 적어 main함수에서 아래에 있는 함수를 읽을 수 있도록 해주었습니다.

5) 문자열과 배열 - 배열을 배우기 시작 할 때 각 데이터 타입마다 몇 바이트씩 미리 크기가 저장 된다고 하였습니다. 하지만 문자열 데이터 타입인 
string은 정해진 용량이 없습니다. 명확히 말해서 컴퓨터의 저장 용량의 한계까지가 string 데이터 타입의 한계크기이죠 
왜 string만 그런 걸까요. 이유를 설명 하기위해선 다시 char 데이터 타입을 생각해봐야합니다. char타입의 크기는 1byte라고 하였습니다. 그리고 
하나의 문자였죠 여기서 문자열이란 이 char타입의 데이터 들의 배열 이라고 할 수도 있습니다. 그러니깐 char가 쭉 나열되어 있는 겁니다. 
그래서 string타입의 정해진 크기가 없는겁니다. 변수로 문자열의 길이가 얼마나 되는지에 따라 용량이 늘어나게됩니다. 그리고 다른 데이터 타입은
정해진 저장 용량이 정해져 있어 정의 했을때 여기까지가 이 변수의 크기라는걸 바로 알수 있지만 string은 변수를 선언할때 적은 글자수 마다 
저장 용량이 다르기 때문에 컴퓨터가 어디부터 어디까지 문자열을 가르키는지 알기 어렵습니다. 그래서 미리 정해놓은 규칙이 있습니다. 
바로 문자열의 맨뒤에 null문자를 항상 추가하여 이 null문자까지가 문자열이라고 알아 볼수 있게끔 하였습니다. 그러니깐 문자열 데이터는 
적은 글자수 +1 만큼의 byte를 가지게 되는겁니다. 
그리고 문자열이 문자타입의 배열같은 것인 만큼 []로 각각 인덱스가 부여되어 있습니다. 가령 

string names[3];
names[0] = "EMMA";
names[1] = "RODRIGO";
names[2] = "BRIAN";
names[3] = "DAVID";

printf("%s\n", names[0]);
printf("%c%c%c%c\n", names[0][0], names[0][1], names[0][2], names[0][3]);
이런 c언어 코드가 있다고 할 때 첫번째 printf는 원래 배웠던 대로 문자열을 출력합니다. 하지만 두번째 printf에서 %c 네개로 names[0][0]
이런식으로 불러오더라도 첫번째 printf와 결과는 같습니다. 사실 문자열을 출력하는 원리가 두번째 printf의 방식인겁니다. 
또 문자열 맨 뒤에는 null문자가 있다고 하였었는데 null문자는 8비트 모두 0인 데이터입니다. 그러면 이 null문자를 출력하면 어떻게 될까요

prinf("%c%c%c%c%c\n", names[0][0], names[0][1], names[0][2], names[0][3], names[0][4]);

를 출력하면 5번째 자리에 아무것도 보이지 않습니다. 하지만 char타입이 아닌 int타입으로 출력하면 EMMA0 이렇게 끝에 0라고 출력이 됩니다. 
값이 어떻든 실제로 존재하기는 한다는 걸 알게 되었습니다. 

이제 문자열이 무엇인지 알아보았고 문자열을 활용해보겠습니다. 
문자열을 인풋으로 받아서 for문에서 %c로 다시 표현하는 코드입니다. 

#include <cs50.h>
#include <stdio.h>

int main(void)
{
  string s = get_string("input:  ");
  prinf("output:  ");
  for (int i = 0; s[i] =! '\0'; i++)
  {
    printf("%c", s[i]);
  }
}

이런 코드라면 어떤 문자열을 입력했을때 for문에서 문자열 s의 i번째 인덱스인 문자가 차례로 출력될 것입니다. 조건은 문자열 마지막에 있는
null문자 가 아니라면 루프 하게되는겁니다. 이 예시는 조금 row한 문제 해결이라고 합니다. 좀 더 사람친화적인 방식으로 생각한다면
문자가 null문자와 비교보다는 이 문자열의 길이가 얼마고 그 길이만큼 루프하는게 더 이해하기 쉬울거 같습니다. 

#include <cs50.h>
#include <stdio.h>
#include <string.h>

int main(void)
{
    string s = get_string("Input: ");
    printf("Output:\n");
    for (int i = 0, n = strlen(s); i < n; i++)
    {
        printf("%c\n", s[i]);
    }
}

위에 string.h 는 문자열과 관련된 함수들이 있는 라이브러리입니다. 이 라이브러리에서 문자열의 길이를 알수 있는 함수인 strlen()를 사용하여 
문자열의 길이를 알아낼수 있었습니다.
다시 문자열의 성질을 조금 응용해서 소문자를 대문자로 변환하는 코드를 짜보겠습니다.

#include <cs50.h>
#include <stdio.h>
#include <string.h>

int main(void)
{
    string s = get_string("Before: ");
    printf("After: ");
    for (int i = 0, n = strlen(s); i < n; i++)
    {
      if (s[i] >= 'a' && s[i] <= 'z')
      {
        //변환 ASCII코드의 표를 보면 소문자는 대문자보다 32 만큼씩 큰 10진법으로 정해져있습니다.
        prinf("%c", s[i] -32);   // s[i] 앞에 (int)를 붙힐 수도 있지만 자동으로 변환해줍니다.
      }
      else {
        printf("%c", s[i]);
      }
    }
    printf("\n");   // 반복문이 끝나고 마지막에 줄바꿈을 해주었습니다.
}

이렇게 for문과 if문의 조합으로 입력받은 정보를 원하는 형태로 가공할 수 있었습니다.
스스로 생각하며 문제를 해결하는 것은 매우 중요합니다. 하지만 현대에는 이미 많은 개발자들이 쌓아놓은 소스들이 많습니다. 
어떠한 타인의 소스도 사용하지않고 자신만의 코드로 모든 작업을 하려고 하는것은 거의 불가능 하다고 할 수 있습니다. 스스로 짠 코드라도
이미 누군가 만들었던 소스 일 확률이 높죠 스스로 고민해서 코드를 짜는걸 반대한다는것은 아닙니다. 오히려 자신의 사고력을 기를 수 있다고 
생각합니다. 다만 자기개발의 목적이 아닌 산업의 관점에서는 능률이 떨어진다고 생각합니다. 
그래서 사실 이 소문자 대문자 변환은 이미 <ctype.h>라는 라이브러리에 내재된 함수가 있습니다. 

#include <cs50.h>
#include <ctype.h>  //ctype.h 를 include합니다
#include <stdio.h>
#include <string.h>

int main(void)
{
    string s = get_string("Before: ");
    printf("After:  ");
    for (int i = 0, n = strlen(s); i < n; i++)
    {
        printf("%c", toupper(s[i]));    // if문으로 구현했던 소문자 대문자 변환하는 함수입니다. 반대로 소문자로 변환하는 함수는 torower()입니다.
    }
    printf("\n");
}


8) 명령행 인자 - 
들어가기 전에
make나 clang과 같은 프로그램을 실행할 때 컴파일하고자 하는 코드 외에도 컴파일 후 저장하고자 하는 파일명과 같이 추가적인 정보를 함께 줄 수도 
있습니다. 이런 정보들을 명령행 인자 라고 부릅니다. 우리가 작성하는 프로그램에서도 명령행 인자를 받을 수 있도록 설계할 수 있습니다.

우리가 지금까지 사용해온 main 함수에 대해 좀 더 자세히 들여다 볼 필요가 있습니다. 눈에 보이지만 의식적으로 무시해왔던 
int main(void)
이렇게 시작하던 코드의 int 부분과 void 부분을 배워보겠습니다. 코드의 형태에서 main도 함수임을 알수 있습니다. 습관처럼 써왔던 void 대신 
argc, argv 를 대신 써보겠습니다.
#include <cs50.h>
#include <stdio.h>

int main(int argc, string argv[])
{
    if (argc == 2)
    {
        printf("hello, %s\n", argv[1]);
    }
    else
    {
        printf("hello, world\n");
    }
}
이 코드에서 첫번째 변수 argc는 main함수가 받게 될 입력의 개수입니다. 그리고 argv[]는 그 입력이 포함되어 있는 배열입니다.
프로그램을 실행할 때 커맨드라인에서 실행하기 때문에 데이터타입은 string입니다.
이 코드를 그냥 컴파일후 실행 했을 때는 hello world가 출력되게 됩니다. 만약 프로그램을 실행하면서 커맨드라인에 이 파일 이름을 쓰고
뒤에 mike라는 문자열을 입력했으면 hello, mike라고 출력이 됩니다. 
코드를 살펴보다 보니 if문안의 argc == 2 라는 조건문이 이상합니다. mike라고 하나의 문자열만 입력했는데 입력갯수가 2개일때 실행되는 
코드가 실행되었습니다. 또 argv[1]가 mike였습니다. 그러면 혹시 아무것도 입력 안해도 argc는 처음부터 1개는 있었고 argv로 어떤 값이 있었는지 
신경쓰입니다. 해서 출력해보면 첫번째 입력값으로 이 프로그램의 파일명이 있습니다. 


  4강 알고리즘

1) 검색 알고리즘 - 배열은 한 종류의 자료형의 데이터들이 메모리상에 모여있는 구조입니다. 컴퓨터는 이 값들에 접근할 때 인덱스 
하나하나에 접근합니다. 배열안의 어떤 값을 찾고 싶으면 배열이 정렬 되어 있는지 여부에 따라 이런 방법들을 사용할 수 있습니다.

1-1) 선형 검색 
배열의 인덱스를 처음부터 끝까지 하나씩 증가시키면서 방문하여 그 값이 속하는지를 검사합니다.
아래 의사코드와 같이 나타낼 수 있습니다.
For i from 0 to n–1

    If i'th element is 50

        Return true

Return false

의사코드로 for문을 표현한것입니다. 배열의 값들이 어떤식으로 정렬되어있는지 모르거나 아예 정령되어 있지 않다면 어쩔 수 없이 
첫 인덱스부터 끝까지 하나하나 확인하면서 찾는 값인지 확인해야 합니다.

1-2 이진 검색
이진 검색은 어떤 방식으로든 배열의 값을 둘씩 나눠가면서 찾는 값으로 접근하는 알고리즘입니다. 이진 검색은 둘로 나누고 어느쪽에 찾는 값이 있는지
알고 있어야 하므로 배열이 어떤 식으로 정렬되어있는지 알고 있어야 하겠습니다.
의사코드입니다.
If no items

    Return false

If middle item is 50

    Return true

Else if 50 < middle item

    Search left half

Else if 50 > middle item

    Search right half


2) 알고리즘 표기법 - 
우리가 프로그램을 작성한 후에 실행하면 작업이 완료될때까지 어느정도 시간이 소요됩니다. 
아주 간단한 프로그램인 경우에는 실행 시간을 걱정할 필요가 없지만, 처리하는 데이터가 많아지고 처리하는 작업이 
복잡해질수록 실행 시간은 매우 중요해집니다. 특정 알고리즘을 작성하였을 때 그 실행 시간을 표기하는 방법을 배워보겠습니다.

알고리즘이 실행될때 극단적으로 생각하면 가장 오래걸리는 경우와 가장 빨리걸리는 경우를 각각 big O(빅 오), Ω(오메가)로 표현합니다.
극단적이지 않는 중간값들은 따로 생각할 필요없이 랜덤하게 발생 할테니까 고려하지 않습니다. 

빅오는 알고리즘이 문제를 해결하는 가장 오래걸리는 경우의 수라고 했습니다. 위에서 배웠던 선형 검색과 이진 검색을 예로들면
션형검색의 경우 문제의 크기와 문제를 푸는 시간이 정비례로 증가할 것입니다. 그럴 경우 O(n)이렇게 표현합니다. 만약 선형인데도 
한번에 1가지씩 확인하는게 아닌 2개 3개씩 확인하는 알고리즘이라도 O(n)이라고 표현합니다. 왜냐하면 충분히 스케일이 커지면 
선형은 비슷한 효율을 가지게 될것이기 때문입니다. 
이진 검색의 경우 문제와 크기와 문제를 푸는 시간이 log n 의 형태로 증가할 것입니다. O(log n)이렇게 표현하겠습니다.

반면 오메가는 알고리즘이 문제를 해결하는 가장 빠른 경우라고 했습니다. 그러면 선형 검색이나 이진 검색 둘다 운이 좋다면 
첫 시도에 문제를 해결 할 수 있으니 Ω(1)이라고 할 수 있겠죠 그러면 언제나 운이 좋다면 어떤 알고리즘이라도 모두 Ω(1)이 
아닌가 생각할 수도 있을 것입니다. 어떤 값을 찾는 검색 알고리즘이 아닌 이 배열에 존재하는 모든 값의 개수를 세는 알고리즘이라면
Ω(n)이라고 할 수 있을 것입니다. 알고리즘이 검색 알고리즘만 존재하는게 아니라고 알 수 있었습니다.

3) 선형 검색 - 
주어진 배열에서 선형 검색으로 값을 찾는 방법을 알아봅니다. 전화번호부와 같이 배열이 여러개가 있는 경우, 한 배열의 특정 속성값을 
찾고 동일한 위치의 다른 배열의 속성값을 출력하는 방법도 배워봅니다. 또, 이를 더 간단하고 확장성있게 구현하는 방법을 배워봅니다. 

선형 검색은 배열의 첫 인덱스부터 끝 인덱스까지 하나 하나 검색하는 알고리즘이라고 했습니다. 특성상 선형 검색은 정확합니다. 
배열의 콘텐츠들을 빠짐없이 확인 했으니 정확하겠죠. 그리고 선형 검색은 비효율적입니다. 선형 검색은 검색하고자 하는 배열의 콘텐츠가 
늘어날수로 정비례로 공정이 늘어납니다. 현대의 방대한 데이터량에서 선형검색은 갈수록 비효율적이 될 것입니다. 
하지만 선형검색이 유용한 상황도 있습니다. 바로 배열의 콘텐츠가 정렬되어있지 않거나 아무런 조건없이 정보를 찾아야 할 때 입니다.
그래서 개발자들에게 정렬은 중요합니다. 정렬은 시간도 더 걸리고 공간도 더 차지 하지만 이후 검색을 할때 더 많은 시간절약을 할 수 있기 
때문입니다. 

어떤 int값을 선형 검색하는 코드를 적어 보겠습니다.
#include <cs50.h>
#include <stdio.h>

int main(void)
{
    // numbers 배열 정의 및 값 입력
    int numbers[] = {4, 8, 15, 16, 23, 42};

    // 값 50 검색
    for (int i = 0; i < 6; i++)
    {
        if (numbers[i] == 50)
        {
            printf("Found\n");
            return 0;
        }
    }
    printf("Not found\n");
    return 1;
}
새로운점은 배열의 콘텐츠를 선언하는데 {}안에 연달아 적는 문법이 새롭습니다. 또 if문과 for문 끝에 return으로 마무리도 했습니다.
return 지점에서 원하는 결과를 얻었으니 프로그램을 끝내기 위해 입력한것 같습니다. 이 코드에서는 검색하는 데이터 타입이 int 였습니다.
그러면 string 타입을 검색해도 같은 결과가 나올까요?

#include <cs50.h>
#include <stdio.h>
#include <string.h>

int main(void)
{
    string names[] = {"EMMA", "RODRIGO", "BRIAN", "DAVID"};
    string numbers[] = {"617–555–0100", "617–555–0101", "617–555–0102", "617–555–0103"};

    for (int i = 0; i < 4; i++)
    {
        if (strcmp(names[i], "EMMA") == 0)
        {
            printf("Found %s\n", numbers[i]);
            return 0;
        }
    }
    printf("Not found\n");
    return 1;
}

int 타입 때와는 조금 다른 코드입니다. strcmp라는 함수를 위해 string.h 라이브러리가 불려왔습니다. 그리고 같은 인덱스 값을 지닌
numbers 배열의 값을 가져왔습니다. 우선 strcmp라는 함수를 써야하는 이유는 string 타입 자체가 int, long, char 같은 데이터 타입과 
다르게 char배열의 형태인 데이터 타입이기 때문입니다. 그래서 찾는 값이 맞는지 확인 하려면 문자열 하나씩 찾는 값과 같은지 확인해야
합니다. 그걸 strcmp 함수에서는 비교할 두 인자를 주면 특정 값을 리턴 해줍니다. 리턴 값이 0면 두 비교대상이 같다, 리턴값이 양수이면
두 비교대상중 앞쪽의 인자가 더 크다, 리턴값이 음수이면 반대로 두번쨰 인자가 크다고 합니다.
이렇게 정적인 정화번호부의 간단한 예시를 만들었지만 아직 부족한 코드입니다. 어느곳이 부족한가 하면 names 배열과 numbers 배열이
서로 같은 인덱스 값이 연관되어 있지만 앞으로 배열들의 크기가 커지거나 만약 names를 알파벳 순으로 정렬하려고 한다면 numbers배열은
무슨 기준으로 정렬해야 두 값의 연관성을 유지 할 수 있을지 알수 없습니다. 이런 경우 두 데이터를 묶어주는 데이터 타입을 
사용자가 새로 정의 할 수있습니다.

#include <cs50.h>
#include <stdio.h>
#include <string.h>

typedef struct
{
    string name;
    string number;
}
person;

int main(void)
{
    person people[4];

    people[0].name = "EMMA";
    people[0].number = "617–555–0100";
    people[1].name = "RODRIGO";
    people[1].number = "617–555–0101";
    people[2].name = "BRIAN";
    people[2].number = "617–555–0102";
    people[3].name = "DAVID";
    people[3].number = "617–555–0103";

    // EMMA 검색
    for (int i = 0; i < 4; i++)
    {
        if (strcmp(people[i].name, "EMMA") == 0)
        {
            printf("Found %s\n", people[i].number);
            return 0;
        }
    }
    printf("Not found\n");
    return 1;
}

이 예시와 같이 typedef struct로 새로 데이터 타입을 정의 할 수 있습니다. 이 데이터 타입의 값을 할당하는 방법도 조금 다릅니다.
이렇게 name과 number를 묶어서 저장할 수 있으면 어떤 식으로 정렬을 하던 괜찮겠습니다.

4) 버블 정렬 -

어떤 배열이 주어졌을 때, 그 배열이 미리 정렬되어 있다면 훨씬 빠른 속도로 검색이 가능합니다. 정렬하기 위한 방법은 여러가지가 있고, 
각각 실행 시간도 다릅니다. 이번 강의에서는 그 중 하나인 버블 정렬을 배워 보겠습니다.

정렬의 방법중 하나인 버블 정렬은 배열에서 두개의 값을 묶어 비교한후 위치를 변경할지 안할지 정해가면서 진행하는 정렬 방법입니다.
이 접근법은 간단하지만 정렬을 하기위해 너무 많은 낭비를 할수 있습니다. 
어떤 배열의 크기가 n만큼 이라고 할때 그리고 배열이 정렬되어 있지 않다고 하면 버블 정렬의 첫 사이클에서 n-1번의 비교가 이루어 집니다.
한 사이클은 배열의 요소 중 하나씩만 정렬이 됩니다. 그래서 다시 반복 또 반복하여 모든 요소가 정렬되도록 해야 합니다.
의사 코드로 나타내면 이렇습니다.
Repeat n–1 times

    For i from 0 to n–2

        If i'th and i+1'th elements out of order

            Swap them
요소의 비교가 0번 인덱스부터 n-2 까지 비교해야하니 총 n-1번 비교이고 또 이걸 n-1번을 반복해야하니
(n-1)*(n-1)번의 비교밑 교환이 일어납니다. 즉 n^2-2n-1번 연산이 이뤄지고 이걸 전에 알아 봤던 알고리즘 표기법으로 표현하면
가능한 최대 횟수는 O(n^2) 입니다. n^2 뒤의 값들보다 n^2의 영향력이 훨씬 크니 n^2로 표현한다고 합니다.
그리고 가능 최소 횟수는 Ω(n^2)입니다. 왜냐하면 이 버블 정렬은 만약 배열이 이미 정렬되어있다고 해도 모든 요소를 다시 다 
비교하게 되는 정렬법이기 때문입니다.

5) 선택 정렬 

앞서 배운 버블 정렬은 직관적이지만 O(n^2)의 시간이 소요됩니다. 이 방법이 최선일까요?  이번에는 다른 정렬 알고리즘인 선택 정렬을 배워보겠습니다.
선택 정렬의 의사코드는 이렇습니다.
For i from 0 to n–1

    Find smallest item between i'th item and last item

    Swap smallest item with i'th item
버블 정렬에서는 두 숫자씩 비교하였다면 선택 정렬은 가장 작은 수 하나를 선택해 작은 인덱스의 값과 바꿔가면서 정렬하는 알고리즘입니다.
선택 정렬과 버블 정렬은 방법의 차이가 분명히 있습니다. 그럼 어떤 알고리즘이 좋은 알고리즘일까요? 좋은 알고리즘은 표현이 애매하니 
선택 정렬의 빅 오와 오메가를 알아 보겠습니다. 
선택정렬의 반복횟수는 n + (n-1) + (n-2) + (n-3) .... 이런 형태입니다. 이걸 수학적 공식으로 정리하면 
n(n+1)/2입니다. 이 식을 전개해보면 (n^2)/2+n/2입니다. 빅오 로 표현하면 O(n^2)입니다. 
오메가의 경우는 선택 정렬도 이미 정렬되어있다고 시행 횟수가 줄지는 않습니다. 왜냐하면 사람과 달리 컴퓨터는 직접 모든 배열의 수를 
비교해가면서 정렬할 것이기 때문입니다. 그래서 오메가도 Ω(n^2)입니다. 
빅 오와 오메가가 버블 정렬, 선택 정렬 둘다 같군요

6) 정렬 알고리즘의 실행 시간 
예를 들어 버블 정렬의 빅 오는 어쩔수 없다고 치고 오메가값 그러니까 실행 최저 시간을 줄일 수는 없을까요 
이전에 배웠던 버블 정렬의 의사코드는 이렇습니다.
Repeat n–1 times

    For i from 0 to n–2

        If i'th and i+1'th elements out of order

            Swap them
배열의 콘텐츠들이 처음부터 정렬 되어있더라도 모든 시행을 실행하는 이유는 맨위 repeat n-1 times 때문이라면 이렇게 바꾸면 조금더 개선 될 것입니다.
Repeat until no swaps

    For i from 0 to n–2

        If i'th and i+1'th elements out of order

            Swap them
이 의사코드의 경우 더이상 스왑이 없을 때 까지 반복하라고 되어있습니다. 이러면 실행 최대시간의 경우 원래의 시간이 걸릴 것이고 
실행 최소시간은 이미 배열이 정렬되어있다면 한번의 체크후 스왑이 일어나지 않았기 때문에 루프가 종료됩니다. 이경우 Ω(n)이 되겠습니다.
이런 개선이 버블 정렬에서만 가능한 것은 아닐것 같습니다. 

7) 재귀 
재귀함수는 함수 안에서 함수를 부르는 걸 재귀하고 합니다. 잘 상상이 안가지만 이렇게 생각하면 어떨까요 
C언어를 배우면서 printf 같은 함수를 사용 했었는데요 이 printf를 main함수 안에서 사용했었죠 지금 말 했다 시피
이미 main함수 안에서 printf같은 함수를 사용 했었습니다. 그러면 만약 사용자정의 함수안에서 또 자기자신의 함수를 
다시 부르면 어떻게 될까요?

재귀의 예를 들기 전에 #이라는 도형으로 입력한 height만큼 계단형으로 출력하는 코드를 짜보겠습니다.
#include <cs50.h>
#include <stdio.h>

void draw(int h);

int main(void)
{
    // 사용자로부터 피라미드의 높이를 입력 받아 저장
    int height = get_int("Height: ");

    // 피라미드 그리기
    draw(height);
}

void draw(int h)
{
    // 높이가 h인 피라미드 그리기
    for (int i = 1; i <= h; i++)
    {
        for (int j = 1; j <= i; j++)
        {
            printf("#");
        }
        printf("\n");
    }
}
이 코드에서는 반복문 안에서 다시 반복문을 사용하여 기능을 구현 했습니다. 이런 코드에서 만약 
다음과 같이 수정하면 어떻게 될까요?
#include <cs50.h>
#include <stdio.h>

void draw(int h);

int main(void)
{
    int height = get_int("Height: ");

    draw(height);
}

void draw(int h)
{
    // 높이가 0이라면 (그릴 필요가 없다면)
    if (h == 0)
    {
        return;
    }

    // 높이가 h-1인 피라미드 그리기
    draw(h - 1);

    // 피라미드에서 폭이 h인 한 층 그리기
    for (int i = 0; i < h; i++)
    {
        printf("#");
    }
    printf("\n");
}
방금 for문을 두번 중첩시킨 코드는 직관적으로 이해가 갔었지만 지금 이 코드에서는 draw라는 함수가 자신의 
내부에서 받은인자-1를 받아 다시 실행 하고 있습니다. 이러면 이 함수에서는 for문이 1번이지만 아까와 같은 
기능을 구현 할 수 있습니다. 주의 할점은 if(h == 0){ return; }으로 재귀함수의 탈출점을 만들어 줘야 한다는
것입니다. 탈출점이 없으면 무한이 자신을 호출하여 컴퓨터가 감당을 못할 지경이 되겠습니다.

8) 병합 정렬 
앞에 배운 버블 정렬 선택 정렬 등은 직관적이지만 실행 시간이 길었습니다. 그러면 위에서 배웠던 재귀를 이용해서 정렬을 한다면 
어떨까요

아직 배우지 않은 대표적인 정렬방법이 하나 더 있습니다. 병함 정렬 merge sort 입니다. 배열을 반으로 나눠가면서 좌우의 크기를 
비교해 가는 정렬법입니다. 의사코드로 적으면 이렇습니다.

만약 배열의 크기가 1이면 리턴합니다.
    반으로 나눈 왼쪽을 정렬합니다.
    반으로 나눈 오른쪽을 정렬합니다.
    각 요소를 순서에 맞춰 병합합니다.

의사 코드만 보면 그냥 말장난 처럼보입니다. 단순히 정렬하고 병합하고 말만 하면 컴퓨터가 알아서 할 수 있는것이 아닐것 같습니다.
그런데 이 의사코드의 두번째 세번째 행의 정렬합니다 라는 말이 이 의사코드를 재귀하는 것입니다. 그러니까 배열의 크기가 1이 될때 까지
반으로 나누는걸 반복해나가고 크기가 1인 배열 두개씩 원하는 규칙으로 병합해 나가는 것입니다.

병합 정렬의 빅 오는 O(n log n)입니다. 배열을 반으로 나누는 과정이 log n 번이고 또 과정에서 각각 n번씩 병합을 해나가기 때문입니다.
또 오메가 또한 Ω(n log n) 입니다. 정렬할 배열이 이미 정렬되어 있는지에 관계없이 전체를 병합 정렬 하기 때문입니다.

이 병합 정렬은 다른 정렬법보다 크게 속도가 빠릅니다. 그러면 어떤 상황에서도 속도가 빠른 병합정렬만을 사용하는게 옳을까요?
하지만 병합정렬에서도 단점이 있습니다. 병합정렬은 배열의 크기가 커질수록 배열을 반씩 나눈후 병합을 할 때 컴퓨터가 기억 하고 있어야 
할 것들이 많아집니다. 메모리를 많이 쓴다는 것입니다.


  5강 메모리

1) 메모리 주소
실제 컴퓨터는 저장공간 메모리가 있고 메모리는 아주작은 0과 1을 나타내는 트랜지스터들이 모여있습니다. 그러면 우리가 코드를 짜면서 
int n 이라는 변수를 만들었을때 컴퓨터는 이 변수를 기억하고 있어야 할것입니다. 메모리의 어느 곳에 4byte만큼의 공간을 점유하는 
변수가 있을 것입니다. 이 변수가 있는 곳의 주소를 알아야 변수를 사용할 때 바로 이 위치로 와서 값을 취할 것입니다. 

메모리 주소는 16진법으로 표현됩니다. 그러니 16진법에 대해 먼저 알아 보겠습니다. 
10진법, 2진법은 이미 배웠었죠 10진법은 0부터 9까지의 숫자를 이용하였습니다. 2진법은 0부터 1까지의 숫자를 이용 하였습니다.
그러면 16진법은 아마 한 자리에 16가지 수를 표현 해야 할 텐데 아라비아숫자는 0부터 9까지 밖에 없으니 10이상은 어떻게 표현 할까요?
바로 알파벳 A부터 F까지를 수로써 표현합니다. 
0 1 2 3 4 5 6 7 8 9 A B C D F 이렇게 16가지의 수를 표현하는 겁니다. 
F가 십진법으로 15를 뜻하고 그럼 16은 어떻게 표현 할까요? 바로 10 입니다. 하지만 이렇게 표현하면 이 수가 10진법인지 2진법인지
16진법인지 햇갈릴 수 있을 것같습니다. 그래서 16진법은 수 앞에  0x를 붙혀서 16진법이라는 것을 표시 합니다. 
예를들어 16진법으로 31은 이렇게 표현할 것입니다.
0x1F

16진수의 유용성
ASCII 코드에 의해 “A, B, C”는 10진수로 65, 66, 67에 해당합니다. 컴퓨터는 10진수를 이해할 수 없으므로 2진수로 표현해보면  
"01000001 01000010 01000011＂이 됩니다. 컴퓨터가 처리할 수 있어야 하기 때문에 어쩔 수 없지만 그 길이가 너무 긴 것을 알 수 있습니다.
하지만 16진수로 표현하면 2진수로 표현했을 때 보다 훨씬 간단해집니다. 또한 컴퓨터는 8개의 비트가 모인 바이트 단위로 정보를 표현합니다.
 2개의 16진수는 1byte의 2진수로 변환되기 때문에 정보를 표현하기 매우 유용합니다.

 10진수      65         66         67
 2진수   0100 0001  0100 0010  0100 0011
 16진수    0x41         0x42      0x43

 메모리 주소

정수형 변수 n에 50이라는 값을 저장하고 출력한다고 생각해 봅시다.

이 n 이라는 값은 int 타입이므로, 아래 그림과 같이 우리 컴퓨터의 메모리 어딘가에 4바이트 만큼의 자리를 차지하며 저장되어 있을 것입니다. 
C에서는 변수의 메모리상 주소를 받기 위해 ‘&’이라는 연산자를 사용할 수 있습니다.

#include <stdio.h>

int main(void)
{
    int n = 50;
    printf("%p\n", &n);
}
이코드를 실행하면 0x123412341234 같은 값을 얻을 수 있습니다. //이값은 예시입니다.
이 값은 변수 n의 16진법으로 표현된 메모리주소 입니다.

반대로 ‘*’를 사용하면 그 메모리 주소에 있는 실제 값을 얻을 수 있습니다. 
#include <stdio.h>

int main(void)
{
    int n = 50;
    printf("%i\n", *&n);
}
위 코드는 먼저 n의 주소를 얻고, 또 다시 그 주소에 해당하는 값을 얻어와 출력한 것이므로 결국 ‘50’이라는 값이 출력되겠죠.


2) 포인터

위에서 연산자 '&'은 뒤에오는 변수의 메모리 주소를 나타 낸다고 하였고 이 주소를 포맷으로 출력 할 때 %p를 사용 하였습니다.
이 p가 pointer입니다. 포인터는 데이터 주소를 쉽게 저장하고 쉽게 접근 할수 있도록 해줍니다.
포인터는 변수로써 선언 할 수도 있는데 보통 변수를 선언 할 때와 문법이 조금다릅니다. 예를들면 이렇습니다.

int n = 50;
int *p = &n;

50이라는 값이 저장된 변수 n이 있고 *p라는 포인터 변수에 n의 메모리주소 즉 &n을 할당한 것입니다.
int *p 에서 p앞의 *는 이 변수가 포인터라는 의미이고, int 는 이 포인터가 int 타입의 변수(n)를 가리킨다는 의미입니다.

3) 문자열

지금까지 문자열이라는 주제를 몇번 다뤄왔습니다. 문자열은 하나 이상의 문자로 이루어진 데이터 타입이다, 사실 문자열은 C에서
기본적으로 지원하는 데이터형이 아니다, 문자열은 사실 char타입의 배열이다 , 문자열은 요소의 개수 만큼 +1의 저장공간은 점유한다
문자열의 마지막 요소는 null 종단 문자로 8비트 전부 0인 요소이다

이런 문자열의 속성들을 배워왔고 이제 포인터라는 개념을 알게 된후 문자열의 정확한 정체를 알 수 있게 되었습니다.

지금까지 실습을 하면서 string타입을 사용하기 위해서 강의에서 제공되는 cs50.h 라이브러리가 필요했었습니다. 같은 방식으로
변수 s에 "EMMA"라는 값을 저장한다고 해보겠습니다.
#include <stdio.h>
#include <cs50.h>

int main(void)
{
    string s = "EMMA";
    printf("%s\n", s);          // 실행결과 EMMA
}

이런 코드에서 변수 s의 "EMMA"라는 문자열은 결국 문자의 배열이고 s[0], s[1], s[2], ... 와 같이 하나의 문자가 배열의 한 부분을
나타냅니다. 마지막 요소에는 \0 이라는 null 종단 문자가 있습니다. 

여기서 변수 s는 결국 이러한 문자열을 가르키는 포인터가 됩니다. 정확히는 문자열의 가장 첫문자의 포인터
즉 s[0]인 'E'를 가르키는 포인터입니다. 우선 맨 앞의 문자를 가르키고 마지막 \0전까지를 문자의 배열로 인식하게 됩니다.

쉽게 string이라는 데이터 타입을 사용 하게 해줬던 cs50라이브러리에는 string 타입은 밑과 같이 정의 되어있습니다.
typedef char *string 
여기서 typedef는 새로운 자료형을, char *은 문자에 대한 포인터를, string은 자료형의 이름을 의미합니다.
따라서 아래같이 정의 해도 string은 동작할 것입니다.
#include <stdio.h>

int main(void)
{
    char *s = "EMMA";
    printf("%s\n", s);
}


4) 문자열 비교 

두 문자열이 같은 내용을 담고 있는지 어떻게 비교할 수 있을까요? 우리가 배운 문자열 자료형을 사용해서 바로 직접적으로 비교가 가능할까요?
 문자열이 저장되어 있는 방식을 자세히 들여다보면서 해서 위와 같은 질문에 대한 답을 해 봅니다.

위에서 예시로 썻던 코드에서 변수 s의 %s값을 출력하는게 아닌 s의 주소에 있는 값은 무었일까요? %c  *s 로 해당 주소로 갈 수 있으니 
출력해보겠습니다.
#include <stdio.h>

int main(void)
{
    char *s = "EMMA";
    printf("%c\n", *s);
}
실행 결과로는 "EMMA"의 첫글자인 E가 출력되었습니다. 변수 s는 E부터 A, 그리고 A뒤의 \0까지를 담고 있었지만 변수 s 자체는 문자열의 
첫글자의 주소를 담고있는 포인터 였으니 문자열의 첫글자만을 출력하게 된 것입니다. 그러면 E 뒤의 문자는 어떻게 출력 할까요
#include <stdio.h>

int main(void)
{
    char *s = "EMMA";
    printf("%c\n", *s);
    printf("%c\n", *(s + 1));
    printf("%c\n", *(s + 2));
    printf("%c\n", *(s + 3));
}
투박하지만 변수 S 자체는 "EMMA"의 첫글자의 주소를 가리키는 포인터였고 E말고 나머지 MMA는 연속적으로 저장 되어 있기 때문에 이렇게 
포인터 s에 1씩 더해가면 "EMMA"라는 문자열 전체에 접근할 수 있게됩니다.
이 *(s + n) 이런 표현들은 s[n]으로 대체 할 수 있었습니다. 이 대괄호 []를 이용한 문법은 syntax sugar라고 불리고 clang같은 컴파일러에서
*(s + n)이라는 명령을 쉽게 표현 해주게 해주었습니다.
이런 로우 레벨의 설명은 현업에서 중요한 것이 아니라고 합니다만 그럼에도 이런 설명을 하는 이유는 C언어나 다른 프로그래밍 언어가 
마치 마법같은게 아닌 기초적인 것들을 조금 씩 개선해와서 사람 친화적으로 만든 것이라는 걸 설명 하셨던 것 입니다.

그럼 이제 다른 예시 코드를 보겠습니다. 이전까지 썻던 cs50라이브러리의 도움을 조금 더 받아야 하겠습니다.
#include <cs50.h>
#include <stdio.h>

int main(void)
{
    int i = get_int("i: ");
    int j = get_int("j: ");
    if (i == j){
        printf("same\n");
    } else {
        printf("different\n");
    }
}
이런 정수를 비교하는 코드가 있습니다. 당연히 i와 j의 입력이 같으면 same 다르면 different가 출력될 것입니다.
그러면 문자열의 경우도 그럴까요?
#include <cs50.h>
#include <stdio.h>

int main(void)
{
    string s = get_string("s: ");
    string t = get_string("t: ");
    if (s == t){
        printf("same\n");
    } else {
        printf("different\n");
    }
}
정수 대신 문자열을 입력받는 코드입니다. 실행결과 로 s와 t가 다른 문자열을 받으면 당연히 different가 출력되고, 
s와 t가 같은 문자열을 받는경우도 differnet가 출력됩니다. 어째서 일까요?
그 이유는 변수 s,t 둘 다 각각 "EMMA"라는 문자열을 저장되었지만 s의 값과 t의 값이 서로 각각 저장 되어있고 
문자열은 문자의 배열이기 때문에 변수에 저장되려면 문자열의 요소중 첫번째 요소의 주소가 변수에 저장 된다고 하였습니다.
C언어에서는 s,t를 비교하게 되면 각변수의 주소가 가리키는 값을 비교하는게 아닌 저장된 주소 자체를 비교하게되고 
그래서 s와 t가 다르다 라는 결과가 되었습니다.


5) 문자열 복사

이번에는 문자열을 복사하고 그 결과가 어떻게 되는지 확인해보겠습니다.
#include <cs50.h>
#include <ctype.h>
#include <stdio.h>

int main(void)
{
    string s = get_string("s: ");
    string t = s;

    t[0] = toupper(t[0]);

    printf("s: %s\n", s);
    printf("t: %s\n", t);
}
이런 코드를 짜봤습니다. 문자열을 저장받는 변수 s에 get_string이라는 입력을 받는 함수로 문자열을 입력 받았고 밑 줄에 
t = s 라는 코드로 복사를 하였습니다. 그리고 두 변수중 t[0]에만 대문자로 바꾸는 함수를 적용 하였습니다. 
확인으로 s와 t둘 다 출력해보면 두 변수 모두 Emma로 출력이 됩니다. 저는 분명 변수 t의 첫글자만 대문자로 변경했는데 어째서 
우 변수모두 변경이 되었을 까요?
변수가 담는 데이터 타입이 문자열이기 때문입니다. 문자열 변수는 첫글자를 가르키는 포인터 즉 첫글자의 주소 라고 하였습니다.
string t = s; 라는 코드에서 변수 t에는 변수 s의 첫글자의 주소가 복사 된것이고 변수 s와 t는 각 변수마다 문자열을 저장 하고있지만
메모리에서 가르키는 곳은 같은 상황 인겁니다. 그래서 t의 첫글자만 수정해도 s도 같은 메모리주소를 가리키고 있으니 두 변수 모두 변경이 
되었습니다.

그러면 의도대로 t변수의 첫글자만 대문자로 수정 하고 싶으면 어떻게 해야 할까요? 밑의 코드를 보겠습니다.
#include <cs50.h>
#include <ctype.h>
#include <stdio.h>
#include <string.h>

int main(void)
{
    char *s = get_string("s: ");
    char *t = malloc(strlen(s) + 1);

    for (int i = 0, n = strlen(s); i < n + 1; i++)
    {
        t[i] = s[i];
    }

    t[0] = toupper(t[0]);

    printf("s: %s\n", s);
    printf("t: %s\n", t);
}
이 코드에서는 변수 t에 malloc이라는 함수를 사용하여 인자만큼의 크기의 메모리를 할당하고 또 변수 s의 원소 갯수만큼의 for문으로 
각 인덱스에 원소 값을 저장하면 각기 다른 메모리에 저장된 같은 문자열 변수 s와 t가 됩니다. 이제 다시 t[0]을 대문자로 수정해서 
출력해 보면 의도 대로 변수 t의 첫글자만 수정 되어있을 것입니다.
위의 코드중
for (int i = 0, n = strlen(s); i < n + 1; i++)
    {
        t[i] = s[i];
    }
부분은 strcpy(t, s); 라는 함수로 대체될 수 있다고합니다. 


6) 메모리 할당과 해제


메모리를 할당한 후에 저장한 값이 필요가 없어지고 나서는 어떻게 해야 할까요? 유한한 메모리를 효과적으로 관리하기 위해서 우리가 
프로그램을 작성하며 할당한 많은 메모리들을 어떻게 관리해야 하는지에 대해 배워보겠습니다.

위에서 썻던 코드 일부분 다시 보면 s변수에 get_string이라는 함수는 프로그램을 실행시 사용자에게 문자열을 입력 받고 그 문자열을
메모리 어딘가에 저장후 첫번째 요소의 포인터를 리턴 해줍니다. 그 리턴받은 포인터를 변수 s에 할당 한것입니다. 
변수 t에 있던 malloc이라는 함수도 비슷합니다. malloc함수가 받는 인자의 크기 만큼의 빈 메모리를 확보하고 그 빈 메모리중 
첫번째 자리의 포인터를 리턴하여 변수 t에 할당한것입니다.
하지만 위의 코드는 아직 버그가 있다고 합니다. 바로 malloc으로 할당한 메모리를 해제 해주어야 한다는 것입니다. 메모리를 해제하는 
함수는 free 라는 함수입니다 malloc과 반대된다고 할 수 있습니다.프로그램에서 사용한후 더이상 필요없는 메모리는 해제 해주어야
메모리의 낭비를 막을 수 있습니다.
그러면 어떻게 free함수를 쓰는지 알아보면 간단합니다. 코드에서 모든 연산 명령 같은 것들이 끝나고 메모리를 해제해도 되는 순서에
free(t);  이렇게 입력하면 됩니다. 여기서는 위의 예시에서 malloc을 사용했던 변수 t를 적었습니다.

커맨드 라인에서 valgrind (컴파일된 파일) 이런 명령어를 입력해보면 입력된 파일의 버그를 확인 할 수 있습니다. 어디에서 문법적 
오류가 생겼는지 이 코드에서 메모리 누수가 생기고 있는지를 알수있습니다.

7)  메모리 교환, 스택, 힙


각각 사이다와 콜라가 들어있는 컵 두 개를 떠올려봅시다. 만약 사이다와 콜라를 각각 다른 컵으로 바꿔 담고 싶으면 어떻게 해야 할까요? 
교환을 도와줄 수 있는 새로운 컵이 잠시 필요하겠죠. 그렇다면 메모리에 저장된 값들을 교환할 때도 이와 비슷하게 할 수 있을까요?

아래와 같은 코드가 있습니다. 함수 swap은 정수 a와 b를 입력받아 그 값을 바꾸는 일을 수행합니다.
main 함수에서는 x에 1, y에 2를 입력하고 swap 함수를 통해 그 두 값을 바꾸려고 하고 있습니다.
과연 의도대로 잘 바뀌어서 출력이 될까요?
#include <stdio.h>

void swap(int a, int b);

int main(void)
{
    int x = 1;
    int y = 2;

    printf("x is %i, y is %i\n", x, y);
    swap(x, y);
    printf("x is %i, y is %i\n", x, y);
}

void swap(int a, int b)
{
    int tmp = a;
    a = b;
    b = tmp;
}
위 코드를 컴파일하고 출력해보면 우리 의도와는 다르게 swap 함수를 거친 후에도 x와 y의 값이 바뀌지 않은채 그대로 출력됨을 알 수 있습니다.
사실 swap 함수는 교환 작업을 제대로 수행하고 있는데요, 문제는 교환하는 대상이 x, y 그 자체가 아닌 함수 내에서 새롭게 정의된 a, b라는 것이었습니다.
a와 b는 각각 x와 y의 값을 복제하여 가지게 됩니다. 서로 다른 메모리 주소에 저장되는 것이죠.

메모리 안에는 데이터가 저장되는 구역이 나뉘어져 있습니다. c언어 컴파일러가 만들때 만든 구조 입니다.
프로그램을 실행 할때 일정 영역의 메모리 구역이 할당 되는데 그중 가장 먼저 우리가 만든 프로그램이 컴파일된 바이너리 이진법의 형태로 저장됩니다.
그 밑에 글로벌 영역이라는 곳에 프로그램에서 저장된 전역 변수가 저장됩니다. 그 밑 으로 heap이라는 malloc으로 할당된 메모리의 데이터가 저장됩니다.
가장 밑에 stack이라는 곳에 프로그램내의 함수와 관련된 것들이 저장됩니다. 
이 네가지 저장 영역에서 힙과 스택은 유동적입니다. 힙은 글로벌 영역에서 아래쪽으로 가능한 한의 영역을 확장 하고 스택은 구역의 밑에서부터 
윗 쪽으로 프로그램의 함수가 사용된 만큼 의 영역을 점유하게 됩니다.

        machine Code
        global
        heap
          ↓

          ↑
        stack

이를 바탕으로 생각해보면 위의 코드에서 인수와 변수인 a, b, x, y, tmp 모두 스택영역에 저장되지만 a, b 와 x, y는 서로 다른 위치에 저장된
변수입니다. 위의 swap함수가 실행 될때 x, y의 값이 a, b에 복사되고 tmp를 이용해 a값과 b값이 스왑되는 연산이 이뤄지지만 
printf에서 불러오는 x, y값은 그대로인 것입니다. 다른 영역에서 이뤄지는 연산이기 때문입니다. 
저는 swap함수로 지역변수의 값을 바꾸는 걸 하고 싶습니다. 어떻게 해야 할까요 
지역변수 x, y의 값을 swap함수의 a, b에 복사하는게 아닌 x와 y의 포인터를 준다면 swap내의 연산에서 변경되는 데이터는 x, y의 주소에서 
이뤄질 것입니다.
#include <stdio.h>

void swap(int *a, int *b);

int main(void)
{
    int x = 1;
    int y = 2;

    printf("x is %i, y is %i\n", x, y);
    swap(&x, &y);                       // main함수에서 실행된 swqp의 인자로 x, y 의 주소를 주었습니다.
    printf("x is %i, y is %i\n", x, y);
}

void swap(int *a, int *b)               // 사용자정의 함수 swap의 인자로 포인터를 받습니다.
{
    int tmp = *a;
    *a = *b;
    *b = tmp;
}

8) 파일 쓰기 
get_int나 get_string처럼 사용자에게 입력을 받는 함수는 어떻게 구현되어 있었을까요? 앞서 배운 메모리 교환,
스택의 정의를 잘 복습한 후에 두 함수를 직접 구현해보고, 더 나아가서 파일에 출력해보는 방법도 알아 보겠습니다.

위에서 배웠던 메모리 구조를 다시 살펴보면 
        machine Code
        global
        heap
          ↓

          ↑
        stack
heap영역과 stack영역이 충돌 할 수 있어 보입니다. heap영역에서는 malloc을 계속해서 사용하면 아래로 확장되어 갈것이고
stack영역에서는 함수가 많아진다면 위쪽으로 확장될 것입니다. 재귀를 사용 할때 프로그램 내에서 너무 많이 자기 자신을 호출하게되면 
stack의 확장이 과도해져서 overflow가 일어나고 이걸 stack overflow 라고 합니다. heap에서 overflow를 일으키면 heap overflow가 되겠죠

이제 cs50강의에서 신세지고 있던 cs50.h 라이브러리를 이해 해보겠습니다.
get_int를 구현 해보면 

#include <stdio.h>          // cs50.h 라이브러리 없이 get_int를 구현합니다.

int main(void)
{
    int x;                  
    prinf("x: ");           // \n 없이 커맨드라인에 출력했습니다.
    scanf("%i", &x);        // 새로운 함수 scanf는 printf와 비슷하게 형식지정자를 받고 그 입력을 &x x의 포인터로 입력해줍니다.
    printf("x: %i\n", x);
}

이번엔 get_string을 구현해보겠습니다.
#include <stdio.h>

int main(void)
{
    char s[5];                  // 배열 자체가 배열의 첫요소의 포인터를 가리키기때문에 포인터 처럼 사용 합니다. 배열의 크기는 동적으로 하는게 더 좋아 보입니다.
    printf("s: ");
    scanf("%s", s);             // 변수 s가 문자의 배열을 가르키니까 &없이 포인터처럼 쓰였습니다.
    printf("s: %s\n", s);
}

cs50라이브러리에서 도움을 받던 함수들을 직접 만들어 봤습니다. 사실 여러 버그들이 많이 있습니다. 지정한 타입의 데이터가 입력되지 않을 시 
처리할 예외처리나 get_string 함수에서는 문자열크기를 미리 정하지 않고 입력한 크기의 메모리를 할당 하는 방법등이 없습니다.

이제 사용자로부터 입력을 받아 파일에 저장하는 프로그램을 작성 해보겠습니다.
#include <cs50.h>           //이번에는 cs50라이브러리의 도움을 받았습니다.
#include <stdio.h>
#include <string.h>

int main(void)
{
    FILE *file = fopen("phonebook.csv", "a");       // file이라는 이름의 포인터를 생성 후 fopen 함수에서 첫번째 인자로 파일이름을 정하고 두번째 인자는 모드로 r은 읽기, w는 쓰기, a는 덧붙이기를 의미합니다.
    char *name = get_string("Name: ");
    char *number = get_string("Number: ");
    fprintf(file, "%s,%s\n", name, number);         // fprintf함수는 커맨드라인이 아니라 지정한 파일에 직접 내용을 출력합니다.
    fclose(file);                                   // 작업이 끝난 후 fclose함수로 파일을 닫습니다.
}

9) 파일 읽기 

우리가 일상적으로 사용하는 파일은 텍스트, 이미지, 영상 등 여러 형식이 있습니다. JPEG 형식의 파일인 경우 그 값 속에는 JPEG파일 형식인지를 알려주는 
실마리가 있습니다. 이번 강의에서는 JPEG 파일을 읽고 그 실마리를 찾아보도록 하겠습니다.

파일명을 입력하면 그 파일이 jpeg 파일인지 확인하는 프로그램을 짜보겠습니다.

#include <stdio.h>

int main(int argc, char *argv[])
{
    // 에러체크로 argc 가 입력이 없으면 프로그램 종료
    if (argc != 2)
    {
        return 1;
    }
    // 파일 읽기 프로그램 실행시 받은 파일명의 읽기 모드로 
    FILE *file = fopen(argv[1], "r");
    // 다시 에러체크로 file 이 null 이면 정확한 파일 이름이 아니니 프로그램 종료
    if (file == NULL)
    {
        return 1;
    } 
    파일에서 3 바이트를 가져옵니다.
    char bytes[3];
    fread(bytes, 3, 1, file);  // 인자 순서대로 (저장할 배열, 가져올 바이트수, 읽을 횟수, 가져올 파일)

    // 파일의 앞에서 부터 3개의 바이트 값이 0xff, 0xd8, 0xff 이면 jpeg파일 입니다.
    if (bytes[0] == 0xff && bytes[1] == 0xd8 && bytes[2] == 0xff)
    {
        printf("Maybe\n");
    }
    else
    {
        printf("No\n");
    }
}