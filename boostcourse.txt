<CS50> 데이비드 j.말란

  1강 컴퓨팅 사고 
컴퓨터사이언스의 개론?에 대한 강의인 cs50에서 첫 강의로 컴퓨팅적인 사고를 주제로 삼았습니다. 강의 순서는
1) 2진법
2) 정보의 표현
3) 알고리즘 
4) 스크래치(비주얼적으로 표현된 코딩 학습도구)
이렇게 4파트로 이루어져 있었습니다. 

1-1 2진법 - 우선 2진법에 대한 이야기는 컴퓨터의 기본 요소이기 때문에 첫 주제로 삼으신거 같습니다.
제가 살아가면서 정확한 이유는 모르지만 얼핏 듣기로는 컴퓨터는 0과 1로 이루어져있다고 듣고는 했습니다. 예전 crashcourse 라는 
유튜브 채널의 컴퓨터 사이언스 강의들을 들은적이 있습니다. 이 cs50강의에서도 언급하였던 것이 컴퓨터의 기본 단위가 트랜지스터 라는 
것이었습니다. 트랜지스터라는 온 오프 상태를 나타낼수 있는 것으로 트랜지스터를 잘 이용하여 2진법으로 표현할 수 있고 또 불리언 값
true는 1, false는 0 라고 간주하여 표현하기도 합니다. 그리고 몇개의 트랜지스터를 알맞게 연결하여 논리회로를 표현하고 , 
더욱 많은 0과 1로 일종의 주소를 만들어 RAM이나 ROM 같은 저장공간, 또 CPU자체가 이런것들을 모아놓은 두뇌라고 들었습니다.
이런 것들을 대략적으로 말하여 컴퓨터가 0과 1로 이루어져 있다 라는 이야기인것 같습니다.

1-2 정보의 표현 - 0과 1로 이루어진 컴퓨터에서 숫자는 2진법을 10진법으로 해석 가능할 것입니다. 하지만 2진법인 숫자를 어떻게 
문자, 이미지, 소리 등을 표현할 수 있을까요? 수십년전 0과 1로 알파벳같은 문자를 표현하기위해 일종의 약속을 하였습니다. "2진법으로 
몇번이라고 하면 이것은 이 알파벳 이야!" 라는 식으로 말입니다. 이것을 ASCII 아스키코드라고 합니다.
American Standard Code for Information Interchange 의 약자인데요 이름에서도 보이듯이 미국에서 정한 기준입니다. 하지만 요즘은 
단순히 알파벳정도만 쓰는정도가 아니죠 여러 나라의 문자도 있고 기본적으로 🤣이런 이모지 도 내장되어있는 새로운 기준을 씁니다.
이 기준의 이름은 Unicode라는 이름입니다. 문자는 이렇게 하나씩 코드를 나열하여 표현한다고 하고 이미지 같은 경우는 어떨까요
다들 픽셀이라는 말을 들어봤을 것입니다. 컴퓨터나 스마트폰 태블릿PC등 디지털 디바이스에서 이미지나 화면의 해상도를 말할때 
픽셀이 얼마나 많느냐 라고 합니다. 이미지를 이루는 픽셀들에 컴퓨터는 2진법으로도 좌표를 지정 할수 있을 것입니다. 또 RGB이라는 
빨강,초록,파랑 이라는 빛의 3원색을 어떻게 조합하느냐로 색을 지정할 수도 있을것입니다. 그러면 하나하나 지정된 좌표의 픽셀이 
어떠한 색이라고 지정한다면 이 픽셀들을 쌓아 하나의 이미지로 보이게 할 수도 있을 것입니다. 이것은 사실 지금 쓰고 있는 텍스트에도 
적용되는 사항입니다 . 이 텍스트도 단색으로 표현된 이미지라고 할 수도 있기때문입니다.😁 소리, 음악, 영상은 어떻게 표현할까요? 
일단 영상의 경우 이미지의 연장선상에 있습니다. 여러 연결된 이미지를 빠르게 보여주는것이 영상입니다. 뇌가 충분히 정지된 이미지를 
움직이고 있다고 착각할 만큼 빠르게 보여주면 되는것이었습니다. 음악, 소리는 같은 원리인데요 소리는 시간에따라 크기, 음계를 진동수
에 하나 하나 숫자를 대입하여 저장 할 수있습니다.

1-3 알고리즘 - 위에서 정보를 입력하는 방식을 배웠습니다. 하지만 컴퓨터는 단순히 정보를 입력하는 것만 할수 있는게 아니죠 
입력한 정보를 어떠한 과정을 거쳐 원하는 출력값으로 받을 수 있습니다. 지금 말한 어떠한 과정이 알고리즘이라고 할 수 있을것 입니다.
알고리즘은 입력값을 출력값의 형태로 바꾸기 위해 어떤 명령들이 수행 되어야 하는지에 대한 규칙들의 순서적 나열입니다.
좋은 알고리즘의 요건에는 정확함과 효율적임이 있어야 할 것입니다. 정보를 가공하는데에 있어 정확한 값이 나오도록 명령들을 나열해야 
할 것이고, 효율적인 명령들로 정보를 가공해야 컴퓨터의 리소스를 절약하여 성능적으로 많은 이득을 봐야 할 것입니다.
예를 들면 탐색하는 알고리즘으로 100페이지의 전화번호부에 천성욱 이라는 이름을 찾는다고 하면 일단 맨 첫페이지 부터 한장씩 찾아보는 방법
이 하나 있을것이고 혹은 전화번호부의 중간을 펼쳐서 이름이 있는지 확인하고 절반의 앞이나 뒤쪽중 해당하는 곳에 절반을 다시 열어보고를 
반복하여 찾는 방법도 있을 것입니다. 둘다 시간을 들이면 확실히 이름이 어디있는지 찾을 수 있을것입니다 이름이 처음부터 전화번호부에 없지만
않다면요. 두 방법다 알고리즘으로써 정확성은 갖추고 있다고 할 수 있겠습니다. 그렇다면 어느 쪽이 효율적인가 살펴보면 첫번째 방법은 
가장 오래걸리는 경우 100페이지를 전부 봐야합니다. 반면 두번째 절반 씩 찾아보는 경우 첫시도에 50페이지, 두번째에 25페이지, 세번째에 12나 
13페이지, 네번째에 6페이지 정도, 다섯번째에 3페이지, 여섯번째에 2페이지 , 일곱번째에 1페이지 가 남는 가장 오래걸리는 경우에 일곱정도에 
찾을수 있을 것입니다.최대 100번의 시도와 7번의 시도 어느 쪽이 효율적인가요 이런식으로 같은 결과를 내고 같은 정확성을 가진 알고리즘이지만 
효율성에는 차이가 있을수 있습니다. 또 이런 알고리즘을 프로그래밍적이면서 사람의 언어로 적어보는 것을 의사코드라고 합니다.예를 들면
1.전화번호부를 집는다.
2.전화번호부의 중간을 펼친다.
3.페이지를 확인한다
4.만약 찾는 이름이 있다면
5.  그 번호로 전화한다.
6.만약 찾는 이름이 절반의 페이지중 앞쪽에 있다면
7.  전화번호부의 앞쪽 절반을 펼친다.
8.  3번째 줄의 명령으로 간다.
9.만약 찾는 이름이 절반의 페이지중 뒷쪽에 있다면
10. 전화번호부의 뒷쪽 절반을 펼친다.
11. 3번째 줄의 명령으로 간다.
12.이도 저도 아니면
13.행위를 중지한다.
이렇게 적는 것이 의사코드입니다. 

  2강 C언어
C언어는 현재까지 사용되는 언어중 매우 오래된 언어에 속하고 또 로우레벨의 언어 컴퓨터 언어에 가까운 언어라고 합니다.
파이썬이나 자바스크립트 같은 언어는 보다 사람 친화적인 언어 하이레벨 언어라고도 불리는데 이때 로우레벨 하이레벨은 
뭐가 더 좋고 나쁜것이 아닙니다. 로우레벨은 기계친화적이고 사람이 배워 사용하기 어려운 언어이지만 속도나 성능은 하이레벨언어에
비해 좋습니다. 하이레벨의 언어는 반대로 배우기쉬운 언어지만 상대적으로 속도가 느립니다. 현대의 컴퓨터는 컴퓨터자체의 
연산속도가 매우 빠르다 보니 이 언어끼리의 속도차이는 생각보다 중요하지 않을 수 있지만 컴퓨터프로그램 중에서도 속도가 중요한 게임
같은데서는 C언어 계열을 사용하고 pc가 아닌 에어컨이나 공장용 혹은 농장에서 사용하는 기계에 들어가는 컴퓨터의 경우 pc만큼의
속도나 메모리가 없기때문에 C언어의 속도나 성능이 필요합니다. 이렇게 용도가 다를뿐 하이 로우 라고 급의 차이는 없습니다.
C언어나 프로그래밍 언어를 배우면서 가장 처음 해보는 것에 hello, world!를 출력해볼텐데요 
#include <stdio.h>

int main(void){
  printf("hello, world!");
}
이런 코드가 됩니다. 첫째 줄에 include한 stdio.h는 printf함수를 사용하기위한 라이브러리 라고 합니다. 파이썬의 경우 단순히
print("hello, world!")
이렇게 간결한 코드로 같은 명령을 내릴수 있습니다. 이런 차이가 로우레벨과 하이레벨언어의 차이점일 것입니다.

"hello, world!"같이 큰 따옴표 안에 하나 이상의 문자가 적혀있으면 이 데이터는 문자열이라는 자료형입니다. 자료형에는 문자열, 정수,
실수, 불리언등 여러 자료형이 있습니다.

사용자 정의 함수 - C언어에서 사용자 정의 함수를 만드는 방법을 학습해 보겠습니다. cough라는 텍스트를 콘솔에 출력하는 함수입니다. 

#include <stdio.h>

void cough(void)
{
  printf("cough\n");
}

int main(void)
{
  for (int i = 0; i < 3; i++){
    cough();
  }
}

이 코드는 cough를 3번 출력해주는 코드입니다. 실제 작동하는 main함수에서 사용자 정의 함수인 cough함수를 for 문으로 3번 반복 실행 했습니다.
작동을 하긴 하지만 메인함수가 밑에 있으면 나중에 사용자 정의 함수가 많아지면 가독성이 떨어질 수 있으니 한번 cough함수를 메인 함수 밑으로 옯겨 봤습니다.

#include <stdio.h>

int main(void)
{
  for (int i = 0; i < 3; i++){
    cough();
  }
}

void cough(void)
{
  printf("cough\n");
}

이렇게 코드를 컴파일 하면 오류가 발생합니다. 메인함수안에 cough()라는 함수를 찾을 수 없다는 말인데 이렇게 C언어에서는 코드가 위에서 아래로 왼쪽에서 오른쪽으로
순서대로만 실행되기떄문에 밑에 사용자 정의 함수를 정의 하기전에 먼저 사용하여 오류가 발생하였습니다. 이럴때 어떠한 테크닉을 쓰면 해결이 된다고 합니다.

#include <stdio.h>

void cough(void);

int main(void)
{
  for (int i = 0; i < 3; i++){
    cough();
  }
}

void cough(void)
{
  printf("cough\n");
} 

이렇게 일단 위에 이름만이라도 함수를 정의 해놓으면 메인 함수에서 실행할때 이런 이름의 함수가 있기는 하다는 듯이 코드 끝까지 읽고 실행이 됩니다.
맨위에 한줄로 적어놓은 간이 함수를 프로토 타입이라고 부릅니다. 이번엔 cough를 for루프로 감싸지 말고 함수 자체에 매개변수를 주어 반복 실행 하고 
싶습니다.

void cough(int n)
{
  for (int i; i < n; i++)
  {
    printf("cough\n");
  }
}

이런 함수를 만들면 함수의 괄호안에 반복하고 싶은 만큼의 정수를 적으면 숫자 만큼 기침을 반복하는 기능을 구현한 것입니다. 이런 기능을 구현하고 
다른 사용자는 이 함수를 사용하면 자세한 구현 방법은 몰라도 직관적으로 기침을 출력해주는 함수고 괄호에는 반복할 정수를 적으면 되겠구나 라고 
알 것입니다. 추상화의 영역입니다. 제가 프로그래밍으로 서비스를 만들며 기능을 구현 할 때 다른 프로그래머가 먼저 만들어놓은 코드들을 가져와서 
쓰는것은 아주 흔한일입니다. 하지만 그렇게 가져와서 쓸때 마다 어떻게 구현됐는지 원리를 하나하나 알아야한다면 작업속도가 매우 느려질 것입니다.
그렇다고 코드의 의미를 알려고 하는것 자체가 잘못된 행동은 아닐겁니다. 오히려 공부가 되면 됐지 다만 비지니스 적으로 효율성을 따지면 별로 좋은
태도가 아닐 것이라는 이야기입니다. 
다음은 조금 다른 사용자 정의 함수 입니다.
#include <cs50.h>
#include <stdio.h>

int get_positive_int(void);

int main(void)
{
    int i = get_positive_int();
    printf("%i\n", i);
}

int get_positive_int(void)
{
    int n;
    do
    {
        n = get_int("Positive Integer: ");
    }
    while (n < 1);
    return n;
}
이번에 CS50 라이브러리도 인클루드했고 프로토타입 함수와 밑에 사용자정의 함수 앞에 int라고 선언 되어있습니다. 이전 까지는 
void function(void) 이런 식이었는데요 이 의미는 앞이 void 이면 함수가 어떤 값을 받아 반환되는게 아닌 경우 입니다.
cough 함수도 printf를 실행했을 뿐 함수가 어떤 값을 반환한것은 아니었습니다. 그러면 이번 get_positive_int 함수는 어떤 기능을 구현 한것
이나면 우선 아무 값이 없는 정수를 받을 수있는 변수 n을 선언합니다. 그 후 do while 문은 우선 do{}에 있는 명령을 실행한 후 while의 
불리언 값에 의해 do{}의 명령이 다시 루프 할지 확인하는 문법입니다. 그러면 do에서 get_int로 어떤 정수값을 입력 받습니다. 질문은 
양의 정수를 달라고 하는군요 그 값을 변수 n에 담습니다. 이제 while로 반복할지 안할지 체크 합니다. n에 저장된 값이 정수 1보다 
작으면 반복합니다. 1이상인 숫자를 입력할때까지. 새로운 개념들이 몇개 있었습니다. int n 이렇게 변수를 지정하는 것을 쓰래기 값 (garbage
value)라고 합니다. 당장은 어떤 값을 넣을지는 모르지만 나중에 값을 달라는 의미라고 합니다. 쓰래기 값 말고 또 
do while 문이 있었습니다. 이것도 루프문인데 전에 배웠던 보통 while 문이나 for 문 과는 어떤 차이가 있을까요? 차이점은 do while문에서는 
do 안에 있는 명령을 일단 한번 실행한 후 반복을 결정하고 보통 while문은 먼저 반복을 결정한 후 명령을 실행하는 차이입니다. 
그래서 위 예시에서는 처음 한번의 입력 질문을 받을 수 있었고 거기서 1이상의 수를 적어 반복에서 빠져나올수 있었습니다.
다음은 중첩 루프의 예시입니다.
#include <cs50.h>
#include <stdio.h>

int main(void)
{
    int n;

    do
    {
        n = get_int("Size: ");
    }
    while (n < 1);

    for (int i = 0; i < n; i++)
    {
        for (int j = 0; j < n; j++)
        {
            printf("#");
        }
        printf("\n");
    }
}

이 코드는 우선 "size: "라는 질문이 출력되고 1이상의 값이면은 밑의 명령이 실행될것입니다. 이 명령부분이 중첩 루프 입니다. for문의 명령부분에 
다시 for문이 있습니다. 이러면 안쪽의 for문이 입력받은 n번 만큼 #을 반복하여 출력하고 줄 바꿈 한 값을 다시 n번 반복하게 됩니다.그 결과 
입력값 n번만큼의 행과 열의 #으로 이루어진 모형이 출력됩니다. 이렇게 루프문을 중첩시켜서 사용할 수 있습니다.


하드웨어의 한계성 - 저는 막연히 컴퓨터는 항상 정확하고 완전무결한 무엇인가 라고 생각 했던거같습니다. 하지만 컴퓨터도 물질로 이루어진 하드웨어에 
불과 합니다. 무엇이든 할 수 있을거 같은 컴퓨터지만 결코 무한한 숫자를 세지 못할 것입니다. 그래서 이번에 하드웨어의 한계에 대해 알아보겠습니다.
#include <cs50.h>
#include <stdio.h>

int main(void)
{
    // 사용자에게 x 값 받기
    float x = get_float("x: ");

    // 사용자에게 y 값 받기
    float y = get_float("y: ");

    // 나눗셈 후 출력
    printf("x / y = %.50f\n", x / y);
}
이런 코드가 있다고 할때 x값으로 1을 주고 y값으로 10을 줘 봤습니다. 당연히 값은 0.1 이 나와야 할 것입니다. %.50f 이렇게 표현 했으니 0.1뒤로 0이 
소수점 아래 50개 까지 이어져야합니다. 하지만 실재 실행값은 
x / y = 0.10000000149011611938476562500000000000000000000000
이렇게 나왔습니다. 이 결과는 아주 이상합니다. 제가 알고있던 수학이 거짓말이었던지 컴퓨터가 거짓말을 하고 있는 것일 겁니다. 
사실 이유는 메모리가 한정되어있어서 입니다. 메모리는 얼마나 큰 메모리라하더라도 결국은 한계가 있습니다. 그러면 부동 소수점에서 소수점 아래로 
얼마든지 내려갈 수 있는데 이 한정된 메모리는 모든 경우의 수의 부동소수점까지 전부 기억하고 있을까요? 그것이 가능 할까요? 아닐 것입니다. 
모든 부동 소수점을 세려고 하다가는 0에서 1까지의 소수점만 세더라도 무한에 가까운 메모리가 필요할것입니다. 그래서 1 나누기 10 이라는 아주 간단한 
문제를 표현할때도 이런 오류가 발생합니다. 저장된 값중에 1나누기 10의 소수점아래 50개까지 가장 가까운 수를 출력 한 것일 겁니다.
부동 소수점에서만 이런 문제가 발생 할까요? 정수에서도 이런 문제는 발생합니다.이런 코드가 있습니다.
#include <stdio.h>
#include <unistd.h>

int main(void)
{
    for (int i = 1; ; i *= 2)
    {
        printf("%i\n", i);
        sleep(1);
    }
}
for문에서 컨디션 부분을 비워 항상 true인 상태로 하여 무한히 반복하도록 하는 반복문입니다. 변수 i는 1의 값부터 시작하여 반복할 때 마다 2를 곱해나갈
것입니다. 아래의 sleep()함수는 unistd라이브러리에 있는 함수입니다. 괄호안의 숫자만큼의 초 를 지연시키는 역할을 합니다. 이 프로그램을 실행하면 결과는 
이렇습니다.
...
1073741824
overflow.c:6:25: runtime error: signed integer overflow: 1073741824 * 2 cannot be represented in type 'int'
-2147483648
0
0
...
1073741824이라는 값부터 에러가 떳습니다. int 타입에서는 이 이상 표현할 수 없다고 하는거 같습니다. 이후 0 이라고 이어지는데 이것도 
수학적으로 거짓말이라서 2제곱을 해나갈 때 일정수 이상 부터는 0인게 아닐 겁니다. int에서는 32개의 비트가 다였기 때문입니다. 
그 이상의 숫자는 저장할 수 없는 것입니다.
이런 오버플로우 문제는 실생활에서도 종종 발견됩니다.
1999년에 큰 이슈가 되었던 Y2K 문제는 연도를 마지막 두 자리수로 저장했던 관습 때문에 새해가 오면 ‘99’에서 ‘00’으로 정수 
오버플로우가 발생하고, 새해가 2000년이 아닌 1900년으로 인식된다는 문제였습니다.그리고 세계는 수백만 달러를 투자해서 프로그래머들에게 더 많은 
메모리를 활용해서 이를 해결하도록 하였습니다.이는 통찰력 부족으로 발생한 아주 현실적이고 값비싼 문제였습니다.

  3강 배열

1) 컴파일링 - 제가 위에서 코드를 작성하고 컴파일해왔지만 컴파일은 4가지 프로세스를 줄여서 간략하게 말한 것이었습니다.
prepocessing, compiling, assembling, linking의 4단계입니다. 순서대로 prepocessing 전처리 단계부터 살펴보겠습니다. #으로 시작되는 C소스코드는 
전처리기에게 실질적인 컴파일이 이루어지기 전에 무언가를 실행하라고 알려줍니다. 예를 들어, #include는 전처리기에게 다른 파일의 내용을 포함시키라고
 알려줍니다. 프로그램의 소스 코드에 #include 와 같은 줄을 포함하면, 전처리기는 새로운 파일을 생성하는데 
 이 파일은 여전히 C 소스 코드 형태이며 stdio.h 파일의 내용이 #include 부분에 포함됩니다.
다음의 compiling은 보통 소스코드에서 머신코드로 바꿔주는 것을 말합니다. 사실 C언어에서 어셈블리 언어라는 것으로 바꿔주는 단계라고 합니다.
그리고 세번째 단계인 assembling이라는 단계가 이 어셈블리 언어로 이루어진 코드를 0과1로 이루어진 머신코드로 바꾸주는 단계입니다. 
이다음으로 linking의 단계가 한 C파일에서 사용돤 여러 코드들을 하나로 뭉쳐주는 단계라고 합니다. include된 파일들을 하나로 뭉쳐 a.out이나 
개발자가 정의한 이름의 파일로 합쳐주는 겁니다. 
그래서 이 4단계를 뭉뚱그려서 컴파일 한다라고 부릅니다.

2) 디버깅 - 버그는 프로그래머라면 필연적으로 경험할 수 밖에 없을 것입니다. 코드작성후 작성한 코드의 디버깅을 하는 것은 매우 자연스러운 일의 
순서입니다. 버그와 디버깅이라는 단어는 실제로 벌레가 컴퓨터에 들어가서 오류를 일으켰던 일화에서 시작된 단어입니다. 현대의 컴퓨터는 손안에 들어오
는 크기의 스마트폰 까지 작아져 있어 실제 벌레가 어떻게 컴퓨터에 들어가는지 이해가 안가실 겁니다. 하지만 초기의 컴퓨터는 트랜지스터가 발명되지 
않았던 시대에도 존재 했습니다. 그 시절에는 진공관같은 걸로 0과 1을 표현하였죠 그래서 아무리 컴퓨터를 소형화 하고 싶어도 거의 방하나를 차지하는
크기였던 시절도 있습니다. 그렇게 거대한 컴퓨터라면 실제 벌레가 들어가 오류를 일으키는건 상상할수 있을 겁니다. 
보통 프로그래머는 IDE라는 통합 개발 환경에서 개발을 하는데 IDE에는 디버깅 도구가 대부분있을것입니다. 디버깅 도구는 어떤 방법으로 프로그래머가
디버깅 하는것을 도와 줄까요 컴퓨터에서 코드가 실행되는 속도가 너무 빠르기 때문에 사람이 실시간으로 실행되는 프로그램의 버그를 인식하는 것은 
불가능 하다고 생각합니다. 그래서 디버깅 도구는 프로그램을 특정 행에서 멈울 수 있게 해줍니다. 이 멈추는 지점을 중지점 이라고 합니다. 
이 중지점에서부터 프로그램이 한번의 프로세싱 하나씩 천천히 살펴보며 프로그램을 실행해 나갈수 있게 해줍니다.

3) 코드의 디자인 - 실제 업무에서 프로그래머 혼자서 모든 코드를 짜는것은 드문 일입니다. 대부분 여러 동료와 함께 협업을 합니다. 이사람 저사람이
모두 같은 코드를 보며 자신이 담당한 부분의 개발을 해나가는데 그래서 코드를 한 프로그래머가 자신만의 형식으로 작성 하면 같이 협업하는 사람들이 
서로 코드를 이해하는데 많은 어려움을 격을 것입니다. 가령 나중에 합류하게된 신입 프로그래머도 팀에서 이미 적어두었던 코드를 이해하는것을 위해서도
코드를 보기쉽게 또 주석을 충분히 사용해 이해하기 쉽게 작성해야 할 것입니다. 
디버깅을 하면서 분명히 막히는 순간이 올것입니다. 아무리 다시 확인하고 구글링도 해보고 해결하려고 멍하니 모니터만 처다보기도 할 것입니다. 
그럴땐 그냥 잠깐 휴식을 하는것도 한 방법입니다. 저도 어떤 오류가 발생하고 해결하려다 시간이 늦어 일단 잠에 들었더니 일어나서 문뜩 
해결방법이 떠오른 경험이 있습니다. 그저 신앙적인 방법론이 아닌 우리 뇌는 자기전 까지 고민했던 문제를 자는동안에 다시 반추해봤던겁니다. 
또 CS50 강의에서 러버덕 디버깅 이라고 하는 방법도 알려주었습니다. 그저 고무오리를 한마리 준비해두고 어떤 문제에 막혔을 때 그 오리에게 
어떤 문제인지 설명해보는 겁니다. 머리속으로 문제에 대해 생각하는것과 남에게 설명하기위해 언어적으로 풀어서 말하며 자신의 귀로도 다시 
듣게되면 일종의 객관적인 관점에서 문제를 바라볼수 있게 되어 문제 해결에 도움이 될 수도 있는 방법론 입니다.

4) 배열 - C언어에는 여러 종류의 데이터형 data type 이 있습니다. bool, char, int, float, long, double, sting 등 이외에도 여러 
데이터 타입이 있습니다. 그리고 변수를 선언할 때 마다 그 변수의 데이터 타입을 선언해야 하는데 각각 데이터 타입마다 다른 크기의 메모리를 점유
하게 됩니다. 예를 들면 bool, char는 1byte의 크기를 가지고 int, float는 4byte의 크기를 가지는 등 메모리를 점유한다는 말이 무슨 의미이냐면
실제 사용하는 컴퓨터들에는 RAM이라고 하는 휘발성 메모리가 있습니다. 1GB,2GB,4GB등등 여러 용량의 RAM이 사용되고 있는데 이 작은 RAM은 
1bit를 나타내는 트랜지스터가 8개 모여서 1byte의 묶음이 되고 또 이 byte들이 약 1천개 모여 kb 킬로바이트가 됩니다. 이렇게 메가바이트, 기가바이트
까지 합쳐놓은게 실제 RAM의 구조일것입니다. 그러면 컴퓨터에서 하나의 변수를 선언해보면 데이터 타입은 불리언 이라고 쳐봅시다. 그러면 RAM의 어느 
한 byte에 제가 정의한 변수의 값이 할당되는 것입니다. 이렇게 소프트웨어로만 생각하면 막연히 무한할것 같았던 저장 용량이 물리적으로 한계가 있을 
수 밖에 없습니다. 
어떤 예시를 들어보겠습니다. 
#include <stdio.h>

int main(void)
{
  char c1 = 'H';
  char c2 = 'I';
  char c3 = '!';
  printf("%c %c %c\n", c1, c2, c3);
}
// 실행결과 : H I !
이 예시에서 몇가지 새로운 사실을 알 수 있습니다. 제가 string타입의 변수를 입력 할 때는 큰따옴표""를 사용해서 선언 했지만 char타입의 변수에서는
작은따옴표''를 사용했습니다. 어떤 원리가 있는것은 아니고 C언어를 만들때 그냥 정한 규칙인겁니다. 
실행결과인 H I !를 얻기위해 사용된 세가지 변수는 RAM의 1byte짜리 공간은 각각 한개씩 할당되었습니다. 
조금 다른 얘기지만 printf에서 %c는 char타입을 불러올때 쓰는 명령어 였습니다. 여기서 H라는 문자 하나는 정말 알파벳으로 컴퓨터에 저장 되어있었나요?
아닙니다. ASCII코드에서 정한 10진법의 숫자에 하나의 알파벳씩 할당되어 있습니다. 그걸 불러온것이죠 그럼 만약 이러면 어떻게 될까요
printf("%i %i %i", (int)c1, (int)c2, (int),c3); // 실행결과 : 72 73 33
이렇게 변수앞에 (데이터 타입)변수 이런 형식으로 쓰면 형변환이 됩니다. 실행결과는 실제 값인지 확실하지않은 제 임의의 값입니다.
컴파일러에 따라 괄호안의 데이터 타입은 생략 될 수도 있다고 합니다.
다시 다른 예시를 들어보겠습니다.
#include <cs50.h>
#include <stdio.h>

int main(void)
{
    // Scores
    int score1 = 72;
    int score2 = 73;
    int score3 = 33;

    // Print average
    printf("Average: %i\n", (score1 + score2 + score3) / 3);
}
어떤 학생의 점수를 평균내는 코드입니다. 이 코드는 약간의 문제점이 있다고 할 수 있습니다. 확장성, int에서만 표현할 수 있다는점, 반복되는 코드가 
있다는 점등 몇몇 문제가 있죠 그 중 코드가 반복되어 사용되는 점에 집중해보겠습니다. score라는 이름의 변수이름이 반복되고있습니다. 이 
변수들은 각각의 점수라는 의미에서 서로 공통점이 있습니다. 하지만 지금 처럼 표현해서는 각각 변수의 이름을 외우고 있어야지만 필요한 데이터를 
찾을 수 있을 겁니다. 이 공통점이 있는 값들을 하나로 뭉쳐서 관리하면 더욱 관리하기 쉽겠죠.
#include <cs50.h>
#include <stdio.h>

int main(void)
{
    // Scores
    int scores[3];
    scores[0] = 72;
    scores[1] = 73;
    scores[2] = 33;

    // Print average
    printf("Average: %i\n", (scores[0] + scores[1] + scores[2]) / 3);
}
이 코드에서 새로운 문법이 등장하였는데 바로 배열 array입니다. int scores[3]; 라는 코드의 의미는 정수타입이고 배열의 이름은 scores입니다.
중괄호 []안의 숫자는 이 배열의 내용물이 몇개나 되니까 이만큼의 저장공간은 내어 달라는 의미죠. 이 3개의 공간이 있는 배열은 0, 1, 2 이런식으로 
순서 index가 정해집니다. 그래서 scores[0] = 72; 라는 코드는 scores배열의 첫번째 자리에 72라는 정수를 저장한다는 의미가 됩니다.

하지만 아직 이 코드는 어딘가 이상합니다. 배열의 크기를 정하는 3과 점수의 평균을 낼 때 사용한 3은 같은 의미를 가지죠 배열의 저장된 점수들의 
총 갯수 입니다. 지금은 이 두개가 같은 의미라는 것을 알지만 언젠가 다시 이 코드를 봤을 때 각각 3 이라는 것 말고 연관성을 떠올리려면 코드 전체를 
다시 살펴야 할것입니다. 이런 상황을 개선하는 방법으로 전역 변수 grobal variable가 있습니다. 예시입니다.
#include <cs50.h>
#include <stdio.h>

const int N = 3;

int main(void)
{
    // 점수 배열 선언 및 값 저장
    int scores[N];
    scores[0] = 72;
    scores[1] = 73;
    scores[2] = 33;

    // 평균 점수 출력
    printf("Average: %i\n", (scores[0] + scores[1] + scores[2]) / N);
}
함수 밖에 N이라는 변수를 선언 했습니다. 이러면 함수안에서만 쓰이는 변수가 아닌 이 파일 전체에 적용되는 변수가 됩니다. 전역 변수이죠
또 int 앞에 const 라는 명령어가 새롭습니다. 상수 constant 라는 의미로 이 N이라는 변수는 실수로라도 값이 변하지 않게끔 고정 시켜줍니다.
변수이름이 대문자로 적히는 것은 프로그래밍적 의미는 없고 그냥 관습이라고 합니다. 
scores의 크기로 전역 변수를 선언하였기 때문에 점수 개수가 바뀌었을때 수정해야 하는 코드가 조금 줄었습니다.
하지만 여전히 일일이 배열의 인덱스마다 점수를 지정해줘야 하는 불편함이 있습니다. 새로운 점수의 평균을 내고 싶을때 저는 다시 이 코드를 열어
과목의 갯수와 각각의 점수를 해당 위치에 적어야 할 것입니다. 저는 더욱 이 프로그램이 동적으로 움직였으면 좋겠습니다.

#include <cs50.h>
#include <stdio.h>

float average(int length, int array[]);

int main(void)
{
    // 사용자로부터 점수의 갯수 입력
    int n = get_int("Scores:  ");

    // 점수 배열 선언 및 사용자로부터 값 입력
    int scores[n];
    for (int i = 0; i < n; i++)
    {
        scores[i] = get_int("Score %i: ", i + 1);
    }

    // 평균 출력
    printf("Average: %.1f\n", average(n, scores));
}

//평균을 계산하는 함수
float average(int length, int array[])
{
    int sum = 0;
    for (int i = 0; i < length; i++)
    {
        sum += array[i];
    }
    return (float) sum / (float) length;
}

점수들의 평균을 내는 코드를 더욱 동적으로 만들어본 코드입니다. 우선 배열의 길이를 get_int함수로 입력받았죠 get_int는 CS50 강의에서 미리 만들어놓은
라이브러리의 함수입니다. 그리고 배열의 길이만큼의 횟수만큼 점수들을 물어봅니다. for문으로 구현되어 있습니다. 
그리고 점수들의 평균을 내는 함수를 따로 사용자 정의 함수로 만들었습니다. 평균은 대부분 부동소수점일 테니까 float의 타입으로 리턴 받습니다.
함수에 두개의 인수를 받는데요 C에서는 배열의 길이를 따로 기억하고 있지 않기 때문에 배열의 길이와 배열 자체를 인수로 받아야 했습니다.
그리고 다음으로 눈여겨 봐야할 곳은 sum을 배열의 길이로 나누면 정수나누기 정수 입니다. C에서는 int 끼리 연산을 하면 그 값도 int형이 나옵니다.
이러면 정확한 평균값을 얻을 수 없습니다. 그래서 return 뒤로 sum과 길이를 (float)로 형변환 해주었습니다. 
그 다음 코드 상단에 평균을 내는 함수의 프로토타입을 적어 main함수에서 아래에 있는 함수를 읽을 수 있도록 해주었습니다.

5) 문자열과 배열 - 배열을 배우기 시작 할 때 각 데이터 타입마다 몇 바이트씩 미리 크기가 저장 된다고 하였습니다. 하지만 문자열 데이터 타입인 
string은 정해진 용량이 없습니다. 명확히 말해서 컴퓨터의 저장 용량의 한계까지가 string 데이터 타입의 한계크기이죠 
왜 string만 그런 걸까요. 이유를 설명 하기위해선 다시 char 데이터 타입을 생각해봐야합니다. char타입의 크기는 1byte라고 하였습니다. 그리고 
하나의 문자였죠 여기서 문자열이란 이 char타입의 데이터 들의 배열 이라고 할 수도 있습니다. 그러니깐 char가 쭉 나열되어 있는 겁니다. 
그래서 string타입의 정해진 크기가 없는겁니다. 변수로 문자열의 길이가 얼마나 되는지에 따라 용량이 늘어나게됩니다. 그리고 다른 데이터 타입은
정해진 저장 용량이 정해져 있어 정의 했을때 여기까지가 이 변수의 크기라는걸 바로 알수 있지만 string은 변수를 선언할때 적은 글자수 마다 
저장 용량이 다르기 때문에 컴퓨터가 어디부터 어디까지 문자열을 가르키는지 알기 어렵습니다. 그래서 미리 정해놓은 규칙이 있습니다. 
바로 문자열의 맨뒤에 null문자를 항상 추가하여 이 null문자까지가 문자열이라고 알아 볼수 있게끔 하였습니다. 그러니깐 문자열 데이터는 
적은 글자수 +1 만큼의 byte를 가지게 되는겁니다. 
그리고 문자열이 문자타입의 배열같은 것인 만큼 []로 각각 인덱스가 부여되어 있습니다. 가령 

string names[3];
names[0] = "EMMA";
names[1] = "RODRIGO";
names[2] = "BRIAN";
names[3] = "DAVID";

printf("%s\n", names[0]);
printf("%c%c%c%c\n", names[0][0], names[0][1], names[0][2], names[0][3]);
이런 c언어 코드가 있다고 할 때 첫번째 printf는 원래 배웠던 대로 문자열을 출력합니다. 하지만 두번째 printf에서 %c 네개로 names[0][0]
이런식으로 불러오더라도 첫번째 printf와 결과는 같습니다. 사실 문자열을 출력하는 원리가 두번째 printf의 방식인겁니다. 
또 문자열 맨 뒤에는 null문자가 있다고 하였었는데 null문자는 8비트 모두 0인 데이터입니다. 그러면 이 null문자를 출력하면 어떻게 될까요

prinf("%c%c%c%c%c\n", names[0][0], names[0][1], names[0][2], names[0][3], names[0][4]);

를 출력하면 5번째 자리에 아무것도 보이지 않습니다. 하지만 char타입이 아닌 int타입으로 출력하면 EMMA0 이렇게 끝에 0라고 출력이 됩니다. 
값이 어떻든 실제로 존재하기는 한다는 걸 알게 되었습니다.