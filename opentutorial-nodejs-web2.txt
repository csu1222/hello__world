#URL :  예시 URL
  http://opentutorials.org:3000/main?id=HTML&page=12
  여기서 http 부분은 protocol 통신규칙 이라고 합니다. 사용자가 서버에 접속 할 때 어떤 방식으로 할 것 인가에 대한 부분입니다.
  그다음 opentutorials.org부분은 host (domain name 이라고도 합니다.) 인터넷에 접속 되어있는 각각의 컴퓨터를 host 라고 합니다. 각 컴퓨터의 이름이라고 할 수 있겠습니다.
  :3000 부분은 port 라고 부릅니다. 한개의 컴퓨터(host)에 여러 서버가 있을 수 있습니다. 그 중 port 번호로 실행된 서버와 통신하기 위한 번호입니다.
  / 뒤에 main 부분은 path 입니다. host 컴퓨터 안에 있는 어떤 디렉토리의 어떤 파일인지를 가르킵니다.
  ?id=HTML&page=12 부분은 query string 입니다. 이 query string으로 앞부분의 서버에게 데이터를 전달 할 수 있습니다. 어떤 가령 id가 HTML인 파일을 원한다. 그리고 복수의 데이터를 전달하기 위해서는 & 으로 연결해줍니다. 다시 page는 12번을 원한다는 의미가 됩니다.

#node.js 에서 url 추출하기 : 예시로 
[protocol] ://[host]:[port]/[query string] 의 형태에서 query string 부분을 추출 하고 싶습니다. 일단 강의 예제 파일은 아래 와 같습니다.
var http = require('http');
var fs = require('fs');

var app = http.createServer(function(request,response){
    var _url = request.url;
    console.log(_url);
    if(_url == '/'){
      _url = '/index.html';
    }
    if(_url == '/favicon.ico'){
        response.writeHead(404);
        response.end();
        return;
    }
    response.writeHead(200);
    response.end(fs.readFileSync(__dirname + _url);
 
});
app.listen(3000);

위 코드에서 8번째 줄에 있는 console.log(_url); 의 출력 값이 콘솔 화면에 query string 부분을 출력 해주었습니다.  그리고 node.js의 기본 모듈인 url을 임포트 하고
 
var url = require('url') 

어플리케이션 안에 query string 을 분석하는 코드를 적습니다.

var queryData = url.parse(_url, true).query;

여기서 parse의 두번째 인수로 true를 주면 query data의 데이터형을 object 로 반환해주고인수가 false였으면 데이터형을 string으로 반환해준다고 합니다.
그래서 console.log(queryData); 를 해보면 query string이 {... : ...}, {... : ...}같이 object로 콘솔에 출력됩니다. 

#동적인 웹 어플리케이션 - 1 
query string으로 어플리케이션에 동적인 변화를 줄 수 있었습니다. 위의 queryData라는 변수는 예를 들어 /?id=HTML이라는 query string을 주면 id 키 값을 가진 오브젝트가 생성되고 queryData.id 이런 식으로 HTML 이라는 값을 얻을 수 있습니다. 이러한 점을 이용해 URL에 query string 이라는 형식으로 어떤 데이터를 입력하면 그에 맞추어 웹이 동적으로 움직일 수 있었습니다.

#파일 읽기 - 정보 시스템의 핵심적인 요소로 CRUD 중 Read에 대해 공부 했습니다. node js 로 file을 읽기 위해 nodejs file read 로 구글링해서 nodejs 공식 document를 찾아 봤습니다.  설명에 따르면 
FileSystem을 require 하고 

var fs = require('fs')

readFile 메소드를 불러 첫번째 인자로 읽어올 파일의 위치를 문자열로 입력합니다. 두번째 인자로 error 와 data 를 인자로 받을 콜백 함수를 줍니다. 콜백 함수에서 data 값을 사용하면 된다고 나와 console.log 로 출력해보았으나 buffer ~~~ 라고 출력이되어 readFile메소드의 두 인자 사이에 문자열로 utf-8 이라는
문자 인코딩 방식을 인자로 준 결과 제대로 출력되었습니다.

fs.readFile('읽을 파일의 경로', 'utf-8', function(err, data){
              console.log(data);
});

여기에 읽을 파일의 경로를 위쪽에 있는
var url = require('url');
var queryData = url.parse(_url, true).query;
의 queryData변수의 id값을 지정하면 웹사이트 query string이 가르키는 값과 같은 이름의 파일을 data 값으로 받을 수 있습니다. 이제 data의 값을 웹사이트의 본문이나 필요한 곳에 입력하면 동적으로 웹사이트의 내용을 표시하면서도 코드상에서도 보기 쉽게 정리할 수 있게됩니다.

# 콘솔에서의 입력값 - 프로그래밍에서 함수는 input 값을 어떤 방식에따라 처리하고 나온 output값 내는 것 입니다. input 값은 parameter 혹은 argument 라고 하는데 parameter는 입력되는 정보의 형식이라고 할 수 있고 argument 는 parameter에 따라 실제로 입력된 값 이라고 합니다. 또 Input 과 Output을 줄여서 IO 라고 부르기도 한답니다. 위에서 실습했던것 중에서는 URL에 query string 으로 input(parameter 또는 argument)을 준 것 입니다.
이번 학습에서는 실용성은 없지만 콘솔에서 직접 input을 주는 방법을 알아 봅니다. 구글에 nodejs console input parameter 정도로 검색을 해보니
 var args = process.argv 같은 코드를 알아내었습니다. 이 args 변수를 콘솔로그 해보니 어떤 배열을 출력해주었는데. 배열의 첫번째 값으로 node.js로 실행 해서 그런지 node.js 가 어디에 설치되어었는지 그 경로를 줬고, 두번째 값으로는 args 변수를 실행한 파일이 있는 경로를 주었습니다. 또 args의 파일을 실행하면서 
node args파일경로 seonguk 
같이 뒤에 seonguk 이라는 그냥 제 이름을 같이 입력하면 args파일이 출력해주던 배열에 세번째 값으로 seonguk 이라는 문자열을 주었습니다. 배열은 0, 1, 2 이런 순서로 인덱스가 부여되기 때문에 
console.log(args[2]); 
를 nodejs 로 실행하면 3번째 값인 seonguk 이 콘솔에 출력됩니다. 


# Not Found page 구현 - 웹페이지에 허용되지 않은 경로로 접속했을 때 유효한 경로가 아니라는 걸 표시하는 기능을 구현합니다. not found 를 구현 하기위해서는 url 이 약속된 쿼리스트링을 가르키는지 아니면 약속되 있지 않은 경로를 가르키는지 알아야 하겠습니다. 위에서 queryData 변수가 있었는데요 그 변수는 이렇게 생겼습니다.
var url = require('url');
var queryData = url.parse(_url, true).query;  //_url은 node.js 에서 서버를 만들었을때 parameter 중 request를 사용해 request.url 한 변수 입니다.//
이중 url.parse(_url, true) 를 콘솔로그 해보면 
 Url {
protocol: null,
slashes: null,
auth: null,
host: null,
port: null,
hostname: null,
hash: null,
search: null,
query: [Object: null prototype] {},
pathname: '/',
path: '/',
href: '/'
} 
같은 값을 출력해주는데 이중 query 항목이 쿼리스트링을 따로 객체의 형태로 보여주고 path는 호스트와 포트 뒤 모든 path입니다. 그리고 pathname은 path 중 쿼리스트링을 제외한 문자열을 보여주는데 이 pathname 을 이용하여 잘못된 경로로 들어왔는지 판별 할 것 입니다. 
javascript의 조건문을 사용하여
if (url.parse(_url, true).pathname === '/' ) {
    '웹페이지에 표시할 본문'
} else {
    response.writehead(404);
    response.end('NOT FOUND');
}
이런 식으로 유효한 path로 접근 했으면 pathname이 / 일 것이므로 본문을 표시 하려던 정보를 표시하고 그 이외에는 404코드와 'NOT FOUND' 라는 텍스트를 표시해주는 작업이었습니다.


# 홈페이지 구현 - 아직 우리는 홈페이지 구현을 안하고 있었습니다. 이제 위에서 NOT FOUND 페이지 구현을 응용하여 쿼리스트링에 id값이 없는 홈페이지를 구현할 수 있습니다. 홈페이지와 목차에 있는 본문들과의 차이점은 path에 id 값을 가지고 있느냐 인데 이를 위해 
var url = require('url');
var queryData = url.parse(_url, true).query; 
라는 queryData변수의 id 값을 조건문으로 구별 하겠습니다.
일단 특이한 다른 path로 접근하는 것이 아니기 때문에 pathname이 '/'이면서 queryData.id 값을 봐야합니다.
if (pathname === '/') {
     if (queryData.id === undefined) {
         '홈페이지의 내용'
    }
} else {
    '다른 본문들의 내용'
}
이렇게 됩니다. 위와 같이 queryData.id 값이 없는 홈페이지라서 undefined 일 때로 조건을 걸면 구분이 되겠습니다.


# Node.js 에서 파일 목록 알아내기 - 웹 어플리케이션에서 파일의 목록들을 수정 할 때 수작업으로 파일 목록을 수정하기는 어려우니 node.js 의 기능으로 자동화 시키는 법을 알아보겠습니다. 구글에서 node js file list in directory 정도로 검색해본 결과 

const testFolder = './data/';
const fs = require('fs');

fs.readdir(testFolder, (err, files) => {
    console.log(files);
});
이런 형식이었습니다. fs를 리콰이어 하고  fs.readdir 메소드로  파일들이 있는 디렉토리를 첫 parameter로 주고 두번째 parameter는 error 와 디렉토리 안에 있는 파일의 파일명을 배열의 형태로 return 해주는 함수를 parameter 로 주게됩니다.
    위에서 알아본 readdir 메소드로 컴퓨터의 파일들을 자동으로 리스팅해서 수정되거나 생성되거나 삭제될 때도 반응하도록 할 수 있습니다. 
console.log(files); 가 있는 부분에 files를 반복문으로 하나씩 처리해서 리스팅을 하면되는데 이런 형태일 것 입니다.

const testFolder = './data/';
const fs = require('fs');

fs.readdir(testFolder, (err, files) => {
    var list = '<ol>';
    var i = 0;
    while (i < files.length){
    list = list + `<li><a href="/?id=${files[i]}">${files[i]}</a></li>`

    i+=1
    }
    list = list + '</ol>';
});

# Node.js javascript의 function으로 중복된 코드 정리하기 - 만들고 있는 웹 어플리케이션에서 반복되는 코드가 있을 수 있습니다. 
그럴때 function으로 중복되는 코드를 묶어서 관리하면 한 눈에 파악하기 더욱 쉬워질 것 입니다. 그러면 function으로 어떻게 코드들을 묶는가 하면

function '함수이름' (parameter) {
    [값을 리턴 하기 전에 여러 처리할 코드]    
    return//반복되는 코드//
}

이렇게 함수를 만듭니다. parameter는 코드 안에 동적으로 반응 하는 부분이 있다면 필요한 부분입니다. [] 안에 처리할 코드는 
만약 return 값을 내기 전에 어떤 처리가 필요할 경우 추가 할 수 있는 부분입니다.

# nodejs 동기적과 비동기적 그리고 콜백 - 동기적(synchronous)과 비동기적(asynchronous)이라는 개념에 대해 배워보겠습니다. 
동기적이라는 것은 몇가지의 처리를 해야할 때 첫번째 처리를 하고 나서 두번째 처리를 하는 식으로 순차적으로 처리해 나가는 것 이라면 
비동기적이라는 것은 첫번째 처리를 하는 중에 시간이 걸리는 동안 다음 처리도 병렬적으로 처리를 시작하는 방식입니다. 
이렇게 들으면 동기적보다 비동기적이라는 개념이 더욱 효율적으로 느껴집니다. 그리고 거의 맞는 말이죠 하지만 비동기적이 효율적이지만 훨씬 복잡한 방법을 가지고 있다고도 보입니다.
node.js 에서 동기적 비동기적을 보려면 node.js 공식문서에서 기본 모듈목록을 봤더니 예를들어 file system 줄이면 fs 항목에 여러 메소드 이름 중 
fs.readFile 와 fs.readFileSync 이렇게 비슷하지만 뒤에 Sync가 붙어있는게 다른 메소드들이 있었습니다.
실습을 위해 파일을 두개 만들었는데 첫째파일은 단순히 B 라는 문자를 적어놓은 txt 파일이고 두번째 파일은 readFile실습을 할 javascript파일을 만들었습니다.
js 파일의 내용은 
var fs = require('fs');

//readfileSync

console.log('readFileSync test')
console.log('A');
var result = fs.readFileSync('example/syncSample.txt', 'utf-8');
console.log(result);
console.log('C');

//readFile


console.log('readFile test')
console.log('A');
fs.readFile('example/syncSample.txt', 'utf-8', function(err, data){
    console.log(data);
});
console.log('C');

이런 내용입니다. readFileSync test의 출력 내용은 A, B, C 순으로 출력되었습니다.
반면 readFile test의 출력내용은 A, C, B 순으로 출력되었습니다. 동기적인 readFile 메소드는 A를 출력하고 readFile이 진행을 다 끝난 다음 
C를 출력한 것이고, readFileSync는 A출력 후 readFileSync를 실행하는 시간동안 C를 출력하고 그사이 처리가 다된 readFileSync처리에 따라 
마지막으로 B가 출력된것입니다.

그리고 콜백에 대해 지금까지 제가 이해한 내용은 node.js에서 함수는 값으로서 변수에 할당 될 수 있습니다.예를 들어 
var a = function () {   <--  함수에 이름이 없는 익명함수 라고 합니다.
    console.log('A);
};
라는 코드는 A를 콘솔에 출력하는 함수를 변수 a에 할당했습니다. 변수에 함수를 할당 할 수 있으니 
function slowfunc(callback){
    callback();
};
라는 코드에 callback이라는 인자에 위에 a라는 값이 함수인 변수를 넣으면 a변수를 함수로 실행되므로 A라는 값이 콘솔에 출력됩니다.
이렇게 어떤 함수안에 인자로서 또 다른 함수를 사용하는것이 콜백이라고 이해했으나 아직 제대로 콜백의 효용이나 원리같은건 실감하지 못하고 있으므로 
더욱 공부해봐야 겠습니다.