<DATABASE> 1   
현대 정보기술에서 데이터의 중요도는 말할 필요도 없이 중요하죠 단순히 기억하기 위해 저장하고 불러오기부터 많은 데이터로부터 
유의미한 패턴들을 파악해 가치를 발생시키는 빅데이터 분야나 이런 빅데이터를 이용해 인공지능의 학습을 돕기도 합니다.
이런 데이터는 두가지 수단으로 관리될 수 있는데요 우선 file의 형태로 저장될 수 있습니다. 파일은 이용하기 매우 간단하고 직관적입니다.
어떤 운영체제에서든지 파일을 이용할 수 있죠 또 이메일같은 서비스를 이용하여 간단하게 파일을 공유할 수 있습니다. 하지만 파일이라고 
만능은 아닙니다. 파일도 어느 부분에서는 성능이나 보안, 편의성에 한계를 가지고 있습니다. 이런 파일의 한계를 극복하기위해 고안된 
소프트웨어가 두번째 데이터를 관리하는 수단인 DATABASE입니다. 데이터베이스는 데이터를 안전하고 편리하고 빠르게 보관하고 사용할 수 있습니다.
데이터베이스에는 여러 제품들이 존재합니다. MySQL, Olacle, MongoDB, SQLite 등등 이 DATABASE 1 항목에서 MySQL, MongoDB같은 서로 다른 
데이터베이스의 공통되는 부분에 대해 공부해보겠습니다. 데이터베이스는 복잡하고 거대하고 위험한 데이터를 다루기 위해 고안된 소프트웨어입니다.
그러므로 데이터베이스를 공부할 때는 상상력을 동원하여 최대한 거대한 데이터를 다룬다는 상황에 공감하며 학습해야 새로 데이터베이스를 배우는 
수고를 납득할 수 있을 것 입니다.

 데이터베이스는 방대한 기능을 가진 소프트웨어입니다. 이런 데이터베이스를 처음 공부 한다고 할 때 모든 요소요소를 각개 격파하면서 배우는 것은 
좋은 방법이 아닐 수 있습니다. 기술들의 공통된 핵심부터 잘 파악하고 공부 할 수 있다면 여러 종류의 데이터베이스 라도 그 핵심되는 기능을 
배웠다고 해도 될 것입니다. 그러면 데이터베이스들의 공통된 핵심은 무엇이냐면 input, output 입력, 출력 입니다. 또 입력은 세가지 종류로 나눌 수 있습니다.
create, update, delete이 세가지로 나눌 수 있죠 출력의 경우 read기능 으로써 표현 될 것입니다. 이 CRUD를 명심 한다면 나머지 데이터베이스의 
기능들은 CRUD를 보좌하는 부가 기능일 것입니다.

 파일과 데이터베이스의 차이점에 대한 예시를 들면 제가 여러 상품에 대한 설명을 파일로 정리하려면 제품의 이름을 가진 txt파일을 만들고 그안에 
제품설명을 적을 것 입니다. 또 파일마다 작성한 날짜, 저자, 저자의 프로필등을 같이 저장하고 싶어서 제품설명 밑에 적었다고 가정해 봅시다. 
이런 식으로 파일로 저장하는 방법은 직관적입니다. 하지만 만약에 이 파일들중에 여러 저자중 특정 저자가 작성한 설명만 보고 싶다거나 작성날짜가
최근인 순서로 정렬 하고 싶을 경우 저는 각각 파일을 열어보고 해당 정보를 찾아서 손수 관리하거나 ctrl + F 로 찾아가면서 정확히 걸러지지 않은 
파일들을 수작업을 해야 할 것입니다. 파일이 몇개 없다면 수작업 할만 할 수 있지 않을까 생각하겠지만 파일이 수천 수만개가 되는 극단적인 상황을 
상상해야 실제 상황에 더욱 도움이 될 것입니다. 이게 파일의 예시라면 데이터베이스의 경우는 예시를 데이터베이스 자체가 아닌 중간단계 비슷한 
스프레드 시트 프로그램으로 예를 들겠습니다. 스프레드 시트는 엑셀, 구글 스프레드 같은 프로그램을 말합니다. 이 스프레드시트는 파일의 경우같이 
여러 제품의 설명을 관리할 때 우선 id 값으로 고유한 번호를 붙일 수도 있고 제품의 이름, 본문, 작성날짜, 저자, 프로필 같이 작성을 시작하기전에 
미리 구조를 만들어 두고 내용을 작성할 수 있을 것입니다. 이렇게 구조적으로 정보를 관리하면 원하는 정보를 손쉽게 뽑아낼 수 있기도 하고 작성날짜 
같은 기준으로 정렬을 하기도 쉽습니다. 스프레드시트가 데이터베이스와 완전히 동일한 개념은 아니지만 파일과 데이터베이스 사이의 개념이기는 합니다.
구조적인 특성을 가지고 있기 때문입니다.

<DATABASE> 2 - MySQL  
MySQL은 무료이면서 오픈소스이고 3대 데이터베이스중 하나입니다. 또한 관계형 데이터베이스이기도 합니다. 관계형 데이터베이스는 여러 제품들이 있는데요
특징상 한가지만 배우면 다른 관계형 데이터베이스를 거의 비슷하게 사용할 수 있다고 합니다.
관계형 데이터베이스와 스프레드시트의 비슷한 점과 다른점을 알아보면서 관계형 데이터베이스에 대해 좀 더 알아보겠습니다. 
우선 스프레드시트, 관계형 데이터베이스 둘 다 표의 형태로 표현할 수 있습니다. 그래서 원하는 정보를 선별적으로 찾을 수 있다는것이 비슷합니다.
다른점은 스프레드 시트는 비주얼적인 인터페이스로 정보를 제어하는것이고 데이터베이스는 코딩, 프로그래밍 언어로 정보를 제어한다는 것입니다.
또 데이터베이스의 다른 특징으로는 데이터베이스에 저장된 데이터를 여러가지 방식으로 나타낼수 있다는 것입니다. 웹으로 표현하거나 빅데이터로 
데이터를 분석하거나 하는 방법으로요. 그 중 웹에서는 전세계 사람들과 통신할 수 있는 특징상 누구나 데이터베이스의 정보를 생성하거나 수적하거나
보고 지울 수 있을 것입니다.

MySQL의 구조에 대해 알아보겠습니다. 총 3가지로 구성되어 있는데요 그 중 첫번째로 우리가 데이터를 입력하는 최종적인 곳이 표(table)입니다.
MySQL, 관계형 데이터베이스는 스프레드시트와 비슷한 표로 데이터를 저장합니다. 이 표는 비슷한 성질의 데이터를 모아 둘 것입니다. 그리고 서비스를 
확장하다보면 각각 다른 성질의 표들이 여럿 생기게 될 것입니다. 이 여러 표들 중 비슷한 내용의 표들을 일종의 폴더 처럼 모아두는 것이 
데이터베이스입니다. 이 데이터베이스라는 표현이 조금 햇갈릴 수 있습니다. 지금 배우고 있는 내용 자체가 데이터베이스인데 표들을 모아두는 폴더도 
데이터베이스라고 부르니깐요. MySQL에서 이 표를 모아두는 폴더로서의 데이터베이스를 스키마(schema)라고도 부른다고 합니다. 이 다음부터는 데이터베이스
대신 스키마라고 부르겠습니다. 그리고 이 스키마가 있으면 다른 분류의 스키마가 여럿 생길 것입니다. 이 스키마를 묶는 더 큰 개념이 데이터베이스 서버
라고 합니다. 그래서 제가 MySQL을 설치하였는데 이 행위는 MySQL이라는 데이터베이스 서버라는 프로그램을 설치한 것이고 이 데이터베이스 서버의 여러 기능을
이용하여 스키마와 테이블로 데이터를 저장하는 것 입니다.

MySQL 서버 접속 - 일단 데이터베이스를 사용하는 장점중 한가지는 보안입니다. 파일은 운영체제만 뚫리면 아무렇게나 수정이 가능하지만 데이터베이스는 자체적인
보안체계를 가지고 있기 떄문에 보다 안전하게 데이터를 보관할 수 있습니다. 그리고 이외에도 권한이라는 기능이 있어서 예를 들어 MySQL에 여러 사용자를 등록
할 수 있는데 사용자마다 권한의 범위를 다르게 줘서 데이터베이스서버 안에 특정 구역만 접근 가능하게 한다던가 전부 접근가능하게 할 수 있습니다.
커맨드 라인에서 MySQL이 설치된 디렉토리에서 밑과 같은 명령어를 입력합니다.
mysql -u[사용자이름] -p
이 명령어는 mysql을 실행하는데 다음 옵션으로 -u 뒤에는 접속할 사용자의 이름을 적습니다. 그중 -uroot 라면 관리자 계정인 root 로 접속 하겠다는 의미입니다. 
그 다음 -p 옵션은 접속계정의 password를 적기위해 입력합니다. -p 없이 접속이 가능하다면 조금더 간편해 지겠지만 암호가 없기 때문에 보안적으로 취약해질 것입니다.
또 바로 mysql -uroot -p1111 
같이 root 계정의 암호가 1111일 경우 -p 뒤에 바로 적어도 접속 가능하지만 이 경우 암호가 화면에 노출 되기 때문에 별로 좋지 않을 것 입니다.

schema or database 만들기 - 먼저 데이터베이스서버에 접속한 후 해야할 일은 데이터베이스 혹은 스키마 라고 하는 큰 틀을 만드는 것입니다. 
그래서 검색 엔진에 mysql create database 정도로 검색을 해보니 그 결과 
CREATE DATABASE '사용할 데이터베이스 이름' 
CREATE TABLE 
이라는 명령어를 찾았습니다. 이중 지금은 CREATE DATABASE 명령어에 대해 알아보겠습니다.
저의 경우 seonguk 라는 이름으로 데이터베이스를 만들었습니다. 번외로 그러면 데이터베이스를 지우는 방법도 알아 봤습니다. 
DROP DATABASE '지울 데이터베이스 이름'
이런 명령어가 나왔습니다. 이렇게 그때 필요한 명령어는 검색을 해보면서 알아가야겠습니다.
SHOW DATABASES 혹은 SHOW SCHEMAS 
명령어로 데이터베이스의 목록을 확인하고 어느 데이터베이스에서 테이블을 만들것 인지 정해야 하니 
USE '데이터베이스의 이름'
명령어로 사용할 데이터베이스로 이동할 수 있었습니다. 

SQL과 테이블 구조 - 본격적으로 mysql을 배우기 앞서 SQL과 테이블구조에 대해 공부하고 나서 다음으로 진행 할 것입니다.
SQL이란 Structured Query Language 의 약자 입니다. Structured는 관계형 데이터베이스에서 원하는 양식에 맞추어 표의 형태로 데이터를 정리
한다고 했는데 이걸 유식해보이는 말로 '구조화', Structured 라고 합니다. Query는 이런 데이터를 생성하고 요청하고 수정하고 삭제하기위해 
질의 한다는 의미의 Query입니다. Language는 앞서말한 내용을 컴퓨터와 사람이 서로 주고 받기위해 약속된 언어로써의 Language입니다.
이런 SQL의 특징으로 쉽고 중요하다는 특징이 있습니다. HTML에 비견될 정도로 쉽고 또 현재 많은 비중을 차지하는 데이터베이스 방법인 
관계형 데이터베이스를 다루기 위해 이 SQL이 표준적으로 사용되는 만큼 중요한 언어입니다.
다음으로 테이블의 구조와 용어를 정리해보겠습니다.

  id    title     description     create
  1     MySQL     MySQL is ...    2022-06-02
  2     Oracle    Oracle is ...   2022-06-03

이런 테이블이 있다고 가정할때 가로로 x축 세로로 y축이 있습니다. 이때 x축을 row, record, 행 등으로 부릅니다. mysql에서는 row라는 표현을 
많이 씁니다. y축을 부르는 용어로는 column, 열 등이 있습니다. 관계형 데이터베이스에서는 보통 column은 데이터 타입을 의미합니다.
위의 예시에서 id, title, description, create 같은 정리된 데이터의 유형들 말입니다. 또 보통 row는 하나의 데이터 자체나 데이터들의 갯수
를 의미하게 됩니다. 예시에서는 mysql, Oracle 같은 걸 말합니다.

테이블의 생성 - 테이블을 만드는 작업에 대해 알아볼 것입니다. 제가 실습으로 표를 작성하면서 최종적으로 작성할 SQL 코드는 아래와 같습니다.
CREATE TABLE topic(
    id INT(11) NOT NULL AUTO_INCREMENT,
    title VARCHAR(100) NOT NULL,
    description TEXT NULL,
    create DATETIME NOT NULL,
    author VARCHAR(15) NULL,
    profile VARCHAR(200) NULL,
    PRIMARY KEY(id)
);
이 코드를 참고하여 각각의 코드가 어떤 역할을 하는지 알아볼것입니다. mysql 테이블을 만드는 치트시트를 검색해보면 간단히 정리한 테이블 생성 
방법이 있습니다. 
CREATE TABLE 테이블이름(
    column1 datatype(length),
    column2 datatype(length),
    ...
)
이런 식으로 설명이 되어있는데요 만들 column을 순서대로 적어나가는 것 같습니다. 저는 첫 column을 id값을 주겠습니다. column 옆에는 
datatype을 입력하라고 되어있습니다. 데이터베이스는 이렇게 column을 작성하면서 내용의 데이터 타입을 제한 할 수 있습니다. 그러면 
서비스를 하면서 기상천외한 유형의 데이터가 섞이는걸 방지 할수 있게 됩니다. 저는 id의 데이터타입을 정수, 그래고 양수인 수로 하고 싶습니다. 
해당하는 데이터타입은 INT(m)이라고 검색 되었습니다. 괄호 안의 m은 얼마까지 표현하는지를 의미한다고 합니다. 여기서는 11 정도로 주겠습니다.
그리고 id값은 꼭 존재해야 해당 데이터를 수정하거나 삭제하거나 할 수 있습니다. 그래서 NOT NULL이라는 명령어를 주면 데이터가 없다는 NULL값을
허용하지 않겠다는 뜻입니다. 그러면 id값이 없는 경우는 오류로써 걸러낼 수 있습니다. 다음은 OUTO_INCREMENT인데 이 명령어는 자동으로 값을 1씩
더하기 한다는 의미로 id값을 중복되지않게 자동으로 부여하는 역할을 합니다. id값으로 데이터를 특정하여 수정하거나 삭제하는게 실수로 다른데이터를
건드리지 않기 때문에 id값은 중복되지않게 유지해야하기 때문입니다.
두번째 column은 title 입니다. 데이터타입은 문자열이구요 제목이 너무 길면 안될 것 같아 100글자 정도로만 제한하고 싶습니다. 또 제목이 null값이
아니었으면 좋겠습니다.그래서 이렇게 입력 했습니다. title VARCHAR(100) NOT NULL 이라고 

이중 데이터타입으로 VARCHAR를 주었는데 의미는 variable character 입니다. 비슷한 데이터타입으로 CHAR 가 있습니다. 두 타입의 차이로는 VARCHAR는 가변 문자열로 괄호로 일정 갯수 제한을 
줬을 경우 입력한 문자열만큼의 문자데이터로 저장이 됩니다. 제한을 넘어가는 문자열이면 한계이후로의 데이터는 잘라냅니다. CHAR의 경우 갯수제한을 
줄 수 있는것 까지는 비슷합니다. 하지만 만약 CHAR(50)일때 데이터 값으로 ABC 라는 문자를 저장하면 ABC이후 length가 50이 될 때까지 나머지 를
빈 문자열로 채웁니다. 데이터를 가져올때는 공백을 제거하고 가져오긴 합니다.
다음 column으로 description을 만들고 싶습니다. 본문의 경우 공백이라도 입력할수 있게 하고 싶습니다. 나중에 본문을 채워 넣을 경우도 있을거니까요
또 VARCHAR나 CHAR는 문자입력이 255개 까지밖에 안됩니다. 본문은 더 긴 내용을 적을 수 있게 하고 싶어서 데이터 타입을 TEXT로 주었습니다. 그래서 
description TEXT NULL 이렇게 적었습니다.
다음 column은 create 데이터 생성 날짜 입니다. 데이터타입은 날짜와 시간이 오면 좋겠습니다. DATETIME으로 주고 생성 날짜가 공백일수 는 없을 것입니다.
그래서 create DATETIME NOT NULL 입니다.
다음 column은 author 작성자 입니다. 작성자는 가변문자열로 30자 정도면 될거같고 익명으로도 글을 쓸 수 있게 하고 싶습니다. 
author VARCHAR(30) NULL 입니다.
마지막으로 profile 작성자의 자기소개 입니다. 가변문자열 200 정도 주고 생략도 할 수 있을것 같습니다.
profile VARCHAR(200) NULL 입니다.
예시의 맨 아래에 있는 PRIMARY KEY(id)는 id column을 이 테이블의 주요 key로 정한것입니다. PRIMARY KEY값으로 지정함으로써 id값이 
중복되지않도록 할 수 있습니다. primary key는 행을 고유하게 구분해주는 최소의 정보입니다. 모든 테이블에는 primary key가 있어야 하며,
오직 하나의 primary key만 존재할 수 있습니다.

// 위 처럼 실습하니깐
ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near 'create DATETIME 
NOT NULL,
author VARCHAR(15) NULL,
profile VARCHAR(200) NULL,
PR' at line 5
라는 오류가 발생했습니다. 네번째 column 이름을 create에서 createtime 으로 바꾸니 해결 되었습니다.
그리고 테이블 생성 성공 메시지에 warning이 하나 있어서 찾아보니 첫째 colmn인 id 데이터타입으로 INT(11)를 썻는데 INT의 length 값이 mysql 8.0 버전이후로 안쓰일 예정이라고 합니다.


CRUD - 정보기술에서 중요하게 여기는 CRUD를 배울 순서 입니다. 대부분의 정보기술과 다르게 데이터베이스에서는 CRUD의 중요도가 조금 다를 수 있습니다.
Create는 정보를 생성해야 이후의 RUD가 의미가 있을 것입니다. Read는 생성한 데이터를 read하지 않으면 생성한 의미가 없을 것이구요 여기 까지는 다른 정보기술과 
비슷하죠 하지만 다음 Update, Delete는 조금 다를 수도 있을 것입니다. 데이터베이스를 웹서비스나 게임등 CRUD모두 중요한 서비스가 있고 반면 연구나 역사같은 분야에 쓰이는
데이터베이스인 경우 저장된 정보들을 수정하거나 삭제하면 오히려 문제가 생길 수 있죠 이런 데이터베이스의 특징에 의한 중요도 차이는 뒤로 하고 일단 CRUD를 하는
방법자체는 모두 알아 둘 필요가 있습니다.

Create(insert): 만들어 놓은 테이블에 정보를 입력하는 명령어는 검색 해보니 
INSERT INTO table_name (column1, column2, column3, ...)
VALUES (value1, value2, value3, ...);
이런 형식이었습니다. 그리고 위처럼 column을 전부 적어야하는데 항상 외우고있기는 어려습니다. 그래서 'DESC table_name'라는 명령어를 
입력하면 콘솔에 테이블의 column구조를 출력해줍니다. 보고 적으면 되겠습니다. 제가 입력했던 table의 column중 id값은 자동으로 1씩 증가하며
입력되게 명령했었습니다. 그래서 id는 생략하고 title 부터 적었습니다.
INSERT INTO topic (title, description, createtime, author, profile) VALUES ('woomirin', 'Seong and Jung', NOW(), 'Seong', '2nd son');
이 명령어들중 createtime의 값에 해당하는부분에 NOW()라는 함수를 사용했습니다. 현재시간을 알려주는 함수 같습니다.

Read(select): 만든 정보를 읽어보겠습니다. 
SELECT * FROM topic; 
이렇게 입력하면 읽을 정보를 선택한다(select), 모든 정보를(*), topic이라는 table로 부터(from)이런 의미인것 같습니다.
여기서 모든 정보가 아닌 선택적으로 읽고 싶으면 * 부분에 필요한 colmn의 이름을 적어주면 되겠습니다.
더 많은 INSERT 문법은 https://dev.mysql.com/doc/refman/8.0/en/insert.html 라는 mysql공식문서를 찾아보면 될것입니다.

Update: 수정하는 법은 대강 이렇습니다.
UPDATE table_name SET column_name=value[,...] WHERE id=id_value;
우선 UPDATE명령어 뒤에 수정하고 싶은 테이블의 이름이 옵니다. SET 명령어로 수정할 column과 테이블 이름을 구문해주고 
바꿀 column이름= 바꿀 값 을 입력합니다. 이뒤의 WHERE가 중요합니다. 만약 이 WHERE를 적지않았다면 table에 모든 row를 수정하게 됩니다.
사고죠 그래서 WHERE로 어떤 row를 수정하고 싶은지 특정하는데 여기서는 PRIMARY KEY로 지정했던 id 값으로 특정했습니다. 이 id값 같이 
다른 row들과 중복되지않는 column을 쓰는게 일반적 일것입니다. 마찬가지로 더욱 많은 기능들이 있지만 
공식문서에서 필요할 때 천천히 찾아보면 되겠습니다.

Delete(DELETE): 삭제하는 방법의 기본은 이렇습니다.
DELETE FROM table_name WHERE id=id_value;
대부분 위 update와 비슷하구요 여기서는 더욱 WHERE가 중요합니다. 실수로 WHERE없이 입력했다거나 잊어버리게 되면 이 table의 모든 row가 
삭제되므로 주의해야합니다.
여기까지 CRUD의 기본을 살펴보았습니다.

관계형 데이터베이스의 필요성 - 지금까지 배운 것들은 관계형 데이터베이스에 대한 핵심이었습니다. 지금배운 핵심에서 좀 더 정교하게 
다룰수 있으면 더욱 관계형 데이터베이스를 잘 한다 라는 것이겠죠. 
관계형 데이터베이스는 구조화 되어있는 특징으로 데이터가 많아졌을때 중복되는 데이터를 필터링하는 것도 편합니다. 
만약 데이터가 많을 때 일부 중복되어 보이는 데이터들이 있다고 가정해봤습니다. 그 중복된 데이터들이 정말 같은 의미의 데이터인지 
확신하기가 매우 어려울 것입니다. 하나하나 철자를 비교해보기도 해야하고 어쩌면 철자는 같지만 다른것을 칭하고 있을지도 모르죠
이럴때 하나의 테이블로만 모든 데이터를 관리하기보다 중복되던 데이터를 따로 분리하여 다른 테이블로 관리하고 
원래 사용하던 테이블에서 필요한 부분에 중복되던 데이터가 있는 테이블의 값을 참조하여 사용 할 수 있을 것 입니다. 
그러면 어떤 데이터들이 중복되는지 명확히 알 수 있고 만약 철자는 같지만 의미가 다른 데이터는 따로 저장하여 참조하면 
햇갈릴 일도 줄게 될것입니다. 
하지만 이렇게 보면 마냥 여러 테이블로 쪼개어 관리하는게 좋아 보일지 모르지만 한편 단점도 생길 것 입니다. 방금의 예시를 
다시 쓰자면 전체적인 데이터를 보는게 아닌 한 row의 정보를 SELECT 하고 싶을 때 다른 테이블로 관리한 column의 데이터는 다시 
그 테이블을 열어 확인해야하는 번거로움이 생깁니다. 게다가 한 두 테이블을 참조하는게 아닌 수십 수백가지의 테이블을 참조해서 
관리하면 그 수 많은 테이블을 일일이 찾아야 할 것입니다.
사실 이런 단점은 현재 관계형 데이터베이스의 단점이 아닙니다. 오히려 관계형 데이터베이스들은 이 문제를 극복했다고 할 수 있습니다.
명령어를 쓰면 알아서 이런 테이블들의 데이터를 합쳐서 보여주면서 중복되는 데이터를 명확하게 알 수도 있습니다.

그러면 위에서 적은 기능을 실습해보겠습니다. 이 실습에서 쓰는 명령어들은 필요할 때에 검색을 하면서 찾으며 구현하는 식으로 
하는게 더욱 효율적 일 것입니다. 
우선 topic이라는 테이블이 있다고 가정하고 이 topic 테이블의 데이터중 중복되는걸 두 테이블로 나눠보겠습니다. 처음 있던 
topic 테이블의 이름부터 바꾸겠습니다.
RENAME TABLE topic TO topic_backup;
이 명령어로 본래 topic테이블을 topic_backup으로 이름을 바꿨습니다. 그다음은 CREATE로 두 테이블을 직접 생성합니다.
CREATE TABLE 테이블이름(
  column_name 데이터타입 NULL or NOT NULL OPTION,
  .....
);
이런식으로 테이블의 column을 정해 구조를 만듭니다. 또 중복된다고 가정한 부분도 만들어야겠죠
이제 join 명령어로 두 테이블을 이어 보겠습니다. 
SELECT 출력하고싶은 column들 FROM 테이블1 LEFT JOIN 테이블2 ON 테이블1.두테이블의 이음세 = 테이블2.두테이블의 이음세;
이러면 서로다른 두 테이블이 자동으로 이어져서 출력됩니다.
이렇게 중복을 제거하면서 따로 데이터를 관리하면 서비스의 볼륨이 클수록 더욱 효율적인 관리가 가능하게 됩니다.
이번 join의 예시는 관계형 데이터베이스를 다루는 한 부분일 것입니다. 이런 일부의 예시만으로도 관계형 데이터베이스의 필요성은
충분히 느껴졌습니다.
